\chapter{Evaluation and opportunities for future development}
\label{chapter:evaluation}

In this chapter, we will attempt to evaluate success of our implementation
based on the research goals and the scope that we have outlined in Chapter~\ref{chapter:methods}.
Besides, we will also evaluate performance of the implementation. As seen from the title,
we have decided to combine the evaluation with discussion on opportunities for further
development. Therefore, we will also propose several ideas for how our implementation
can be improved and extended.

\section{Decidability of a wide range of problem families on trees}

The first goal among the research goals listed in Chapter~\ref{chapter:methods}
was to store (or to be able to compute dynamically) most
(if not all) of the existing knowledge on classification of LCL problems on trees.
To evaluate how well we have done, we can refer once again to Table~\ref{table:summary}.
The first three columns under the "Paths and cycles" grouping refer to LCL problems on
paths and cycles where input is not allowed. The graphs can be directed or undirected,
have arbitrary (but finite) number of labels in the output, and have restrictions
on nodes of degree 1 (in cases of paths). All of these cases are covered by
the cycle-path classifier~\cite{FIXME}, which is based on the recently
published paper~\cite{FIXME}. The classifier has been integrated into our
solution an, thus, we claim that the problems of this family are fully classifiable by our tool.
The forth column of the table refers to LCL problems on paths and cycles
where input labelling is allowed. Since none of the used classifiers
are capable of processing problems with inputs, this family of problems
has not been covered by our implementation, although it has been shown that
LCLs of this class are decidable (even though it is PSPACE-hard)~\cite{Balliu2018}.

As can be seen from the first column of the "Tree" grouping, it is unknown whether
unlabeled regular homogeneous~\cite{BalliuHomogeneous}
undirected trees are classifiable if the number of
output labels exceeds two. On the other hand, LCL problems on
unlabeled regular undirected trees with binary label output is fully decidable, albeit
only in deterministic setting. In addition to this, for some problems of the problem family,
complexity is decidable even in randomised setting~\cite{Balliu2019c}.
Since our solution does not directly include a classifier that would implement
classification of problems of the described family, our tool is not capable of
classifying the problems. It is important to notice however that the TLP
Classifier~\cite{Rocher2020clas} uses the classifier as part of its implementation.
Therefore, at least some problems of the described family can be classified. Specifically,
only problems on (2, 2)-, (2, 3)-, and (3, 2)- biregular trees of the family
(and only in deterministic setting) can be classified in our implementation.
Therefore, a natural opportunity for extending the current functionality of the tool
would be to integrate a clasifier that would classify all binary labeling LCL problems
on unlabeled regular undirected trees. Given that such implementation would
essentially involve a simple table lookup (the authors of the original paper
reduce the classification problem to a two-dimensional table lookup), the
classifier could work efficiently even with trees of relatively high degree.

The next column in the table is for LCL problems on unlabeled regular directed
trees. It has been shown that the problems of this family are fully decidable
with any finite number of output labels~\cite{Balliu2021}. However, the
only currently-existing implementation of the decidability algorithm
works exclusively with binary rooted trees~\cite{Studeny2021}. The
meta-algorithm has been successfully integrated into our solution, and
thus all LCL problems on binary rooted trees can be classified also In
practive using our tool. Nevertheless, an implementation of the
decidability algorithm that would work for trees of higher degrees
would be of high interest to the research community. The original
paper shows that such implementation for arbitrary number of output
labels is possible at least in principle. Besides, there is no
evidence that such implementation would be impractical from the
performance perspective. Therefore, a natural opportunity for
extending the software would be to build such an implementation and
consequently integrate it in our tool.

All other -- more general -- LCL problem families
are currently only known to be decidable between complexity classes of
$\Omega(\log n)$ and $O(n)$~\cite{Chang2020a}. There are currently
no known implementation of the classification algorithm described in the
referenced paper. Although the described meta-algorithm is at least
EXPTIME-hard, there is also no evidence that the algorithm wouldn't be
practical at least for a limited subfamily of problems. Therefore, its
implementation and integration into our solution would be a potential
direction for the tool's future development.

Thus, while many of the listed graph families are already classifiable
with our tool, a lot more meta-algorithms can be developed
and integrated in our solution. Moreover, the theoretical
research of decidability of LCL problems on tree is currently
developing at a high pace, which will likely bring even more
positive theoretical decidability results in the future.
It is then the task of the practitioners to catch up with
the theory and make the practical decidability landscape
as complete as possible.

\section{Finding a problem's complexity and performing group queries}

The two other goals in our list of the research goals were

\begin{enumerate}
  \item to be able to find deterministic and randomised complexity of
  of a particular problem $P$, provided that the problem belongs to
  one of the classes that one tool is capable of classifying,
  \item to be able to query for groups of multiple problems based
  on a variety of parameters.
\end{enumerate}

As can be deduced from Chapter~\ref{chapter:implementation},
both of these functionalities have been succesfully implemented.
Notice that we address performance issues in another section later in
this chapter, as well as we have already evaluated the number of
problem families our tool is capable of working with. In this section,
we are discussing just the availability of the functionality itself, while not
being concerned with other -- although related -- metrics.
Thus, we can conclude that the two goals have been full accomplished.

As a final research goal in our list, we had a possibility
to see which of the meta-algorithms has determined each
of the lower and upper bounds for each of the preclassified
LCL problems being stored in our database. As described in the
previous chapter, this is automatically done for all problems being
classified via our solution. At the same time as a problem is classified,
all of its classification results -- deterministic upper bound,
deterministic lower bound, randomized upper bound, randomized lower bound --
are associated with one of the meta-algorithms. This information is also
persisted in the database at the same time a newly classified problem
is being stored. Thus, we can consider this research goal as being
fulfilled as well.

\section{Performance}

In this section, we will evaluate our implementation from
performance perspective. Performance is essential for
our tool to be useful for the research community.
We will evaluate performance of our tool
in the context of classifying a single LCL problem,
generating and classifying a huge but finite family of
LCL problem, and querying the database for a group
of problems matching user-defined specification.

% speed of classifying a problems

% speed of getting batch query resutls

% speed of batch classification

\section{Number of preclassified problems}

At the moment of writing the thesis, the database contains 335314
LCL problems. Out of them, 197218 have at least one non-trivial bound. \emph{Trivial bound} here
refers to $\Omega(1)$ for lower bounds and "unsolvable" for upper bounds.

The following families of LCL groups have been pre-generated batch classified
using the batch classification functionality described in Chapter~\ref{chapter:implementation}:

\begin{itemize}
  \item binary labeling problems on both directed and undericted paths and cycles
  \item ternary labeling problems on both directed and undirected paths
  \item 4-labeling problems on undirected paths
  \item binary labeling problems on both rooted and unrooted (3, 2)-biregular trees
  \item ternary labeling problems on unrooted (3, 2)-biregular trees
  \item ternary labeling problems on rooted (3, 2)-biregular trees where passive configurations are monochromatic
  \item 4-labeling problems on rooted (3, 2)-biregular trees where active configurations are monochromatic
  \item a part of 4-labeling problems on directed paths
  \item a part of ternary labeling problems on rooted (3, 2)-biregular trees (with no constraints on active or passive configurations)
  \item a part of 4-labeling problems on rooted (3, 2)-biregular trees where passive configurations are monochromatic
\end{itemize}
Notice that in all of the problem families listed above, leaf and root nodes
(or equivalently nodes of degree one on paths) are unconstrained. Moreover, in addition to the
groups of preclassified problems, the database contains several individual problems that
were added as a result of the application being used by several of the members of the
distributed algorithms research community.

Thus, it is evident that the number of preclassified problems is already at this stage sufficient
for the tool to be useful to the research community. Populating the database
with more problems of more diverse problem families is a natural opportunity for future
development.

\section{Miscellaneous}
% currently label count is UB. People want to be able to specify a LB for labels used
% people want to query for only fixed-points problems
% people want to query for problems of exact constant complexity
% restrictions on what output nodes can produce is currently somewhat limited (at least there is no differentiation between active/passive nodes)
