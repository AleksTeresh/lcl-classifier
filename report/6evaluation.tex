\chapter{Evaluation and further enhancements}
\label{chapter:evaluation}

In this chapter, we will attempt to evaluate success of our implementation
based on the research goals and the scope that we have outlined in Chapter~\ref{chapter:methods}.
Besides, we will also evaluate performance of the implementation.
As seen from the title,
we have decided to combine the evaluation with discussion on opportunities for further
development. Therefore, we will also propose several ideas for how our implementation
can be improved and extended.

\section{Decidability of a wide range of problem families on trees}

The first goal among the research goals listed in Chapter~\ref{chapter:methods}
was to store (or to be able to compute dynamically) most
(if not all) of the existing knowledge on classification of LCL problems on trees.
To evaluate how well we have done, we can refer once again to Table~\ref{table:summary}.
The first three columns under the ``Paths and cycles'' grouping refer to LCL problems on
paths and cycles where input is not allowed. The graphs can be directed or undirected,
have arbitrary (but finite) number of labels in the output, and have restrictions
on nodes of degree 1 (in cases of paths). All of these cases are covered by
the cycle-path classifier~\cite{Tereshchenko2020}, which is based on the recently
published paper~\cite{Chang2020}. The classifier has been integrated into our
solution and, thus, we claim that the problems of this family are fully classifiable by our tool.
The forth column of the table refers to LCL problems on paths and cycles
where input labelling is allowed. Since none of the used classifiers
are capable of processing problems with inputs, this family of problems
has not been covered by our implementation, although it has been shown that
LCLs of this class are decidable (even though it is PSPACE-hard)~\cite{Balliu2018}.

As can be seen from the first column of the ``Tree'' grouping, it is unknown whether
unlabeled regular homogeneous~\cite{BalliuHomogeneous}
undirected trees are classifiable if the number of
output labels exceeds two. On the other hand, LCL problems on
unlabeled regular undirected trees with binary label output is fully decidable, albeit
only in deterministic setting. In addition to this, for some problems of the problem family,
complexity is decidable even in randomised setting~\cite{Balliu2019c}.
Since our solution does not directly include a classifier that would implement
classification of problems of the described family, our tool is not capable of
classifying the problems. It is important to notice however that the TLP
Classifier~\cite{Rocher2020clas} uses the classifier as part of its implementation.
Therefore, at least some problems of the described family can be classified. Specifically,
only problems on (2, 2)-, (2, 3)-, and (3, 2)-biregular trees of the family
(and only in deterministic setting) can be classified in our implementation.
Therefore, a natural opportunity for extending the current functionality of the tool
would be to integrate a clasifier that would classify all binary labeling LCL problems
on unlabeled regular undirected trees. Given that such implementation would
essentially involve a simple table lookup (the authors of the original paper
reduce the classification problem to a two-dimensional table lookup), the
classifier could work efficiently even with trees of relatively high degree.

The next column in the table is for LCL problems on unlabeled regular directed
trees. It has been shown that the problems of this family are fully decidable
with any finite number of output labels~\cite{Balliu2021}. However, the
only currently-existing implementation of the decidability algorithm
works exclusively with binary rooted trees~\cite{Studeny2021}. The
meta-algorithm has been successfully integrated into our solution, and
thus all LCL problems on binary rooted trees can be classified also In
practive using our tool. Nevertheless, an implementation of the
decidability algorithm that would work for trees of higher degrees
would be of high interest to the research community. The original
paper shows that such implementation for arbitrary number of output
labels is possible at least in principle. Besides, there is no
evidence that such implementation would be impractical from the
performance perspective. Therefore, a natural opportunity for
extending the software would be to build such an implementation and
consequently integrate it in our tool.

All other -- more general -- LCL problem families
are currently only known to be decidable between complexity classes of
$\Omega(\log n)$ and $O(n)$~\cite{Chang2020a}. There are currently
no known implementation of the classification algorithm described in the
referenced paper. Although the described meta-algorithm is at least
EXPTIME-hard, there is also no evidence that the algorithm would not be
practical at least for a limited subfamily of problems. Therefore, its
implementation and integration into our solution would be a potential
direction for the tool's future development.

Thus, while many of the listed graph families are already classifiable
with our tool, a lot more meta-algorithms can be developed
and integrated in our solution. Moreover, the theoretical
research of decidability of LCL problems on tree is currently
developing at a high pace, which will likely bring even more
positive theoretical decidability results in the future.
It is then the task of the practitioners to catch up with
the theory and make the practical decidability landscape
as complete as possible.

\section{Finding a problem's complexity and performing group queries}

The two other goals in our list of the research goals were

\begin{enumerate}
  \item to be able to find deterministic and randomised complexity of
  of a particular problem $P$, provided that the problem belongs to
  one of the classes that our tool is capable of classifying,
  \item to be able to query for groups of multiple problems based
  on a variety of parameters.
\end{enumerate}

As can be seen from Chapter~\ref{chapter:implementation},
both of these functionalities have been succesfully implemented.
Notice that
we address performance issues in another section later in
this chapter, as well as
we have already evaluated the number of
problem families our tool is capable of working with. In this section,
we are discussing just the availability of the functionality itself, while not
being concerned with other, although related, metrics.

% Finding out complexity of a specific problem takes consistently under
% 2 seconds, and performing a query might take from as little as several milliseconds
% in some cases to several seconds in most cases
% up to just under 35 seconds in rare cases when the volume of the queried data is particularly large.
% Notice that the rough performance results presented above are as measured
% from the perspective of the Web interface user, and thus include
% network delay as well as time it takes for the front-end logic to process
% and render the results.
% Thus, we can conclude that the two goals have been fully accomplished.

As a final research goal in our list, we had a possibility
to see which of the meta-algorithms has determined each
of the lower and upper bounds for each of the preclassified
LCL problems being stored in our database. As described in the
previous chapter, this is automatically done for all problems being
classified via our solution. At the same time as a problem is classified,
all of its classification results --- deterministic upper bound,
deterministic lower bound, randomized upper bound, randomized lower bound --
are associated with one of the meta-algorithms. This information is also
persisted in the database at the same time a newly classified problem
is being stored. Thus, we can consider this research goal as being
fulfilled as well.

\section{Performance}

In this section, we will evaluate our implementation from
performance perspective. Performance is essential for
our tool to be useful for the research community.
We will evaluate performance of our tool
in the context of classifying a single LCL problem and
querying the database for a group
of problems matching user-defined specification.

Notice that the purpose of this section is to evaluate how
useable the tool is from the perspective of its users.
Therefore, we are not concerned with exact millisecond
precision of the operations. Instead, we will present
the performance results with the precision down to a tenth of a second.
Notice also that the times will vary depending on the underlying
hardware, the fact whether other users are using the tool at the same
time, etc. All the results presented below are performed on the
author's local machine, whose exact specifications are given below.

Finally, when presenting results for classifying a problem or
performing a query, we measure the time it takes
for the corresponding function to execute as defined in the back-end
part of our solution. Therefore, the time as experienced by the users of
the Web interface might be somewhat longer since it would include
also a network delay and executing front-end logic.

\subsection{Classifying a problem}

If a requested problem already exists in the database, finding out
the problem's complexity consistently takes less than a second.
On the other hand, if a problem has to be classified dynamically,
classifying it will take less than 3.2 seconds (at least in case when
problems degrees are less than 5 and the number of labels allowed is less
than 5 as well). Below are some of the performance measurement results,
based on which the above-mentioned conclusions has been drawn.

\begin{itemize}
  \item Any 2-labeling problem on undirected paths is classified in \emph{under 0.1 sec.}
  \item Any 3-labeling problem on directed (3, 2)-biregular trees is classified in \emph{under 0.7 sec.}
  \item Any 3-labeling problem on undirected (3, 2)-biregular trees where passive configurations are monochromatic is classified in \emph{under 3.2 sec.}
\end{itemize}

\subsection{Querying a problem family}

Below is a similar list of performance results for the querying
functionality. The query that retrieves the largest problem class, in terms of
number of problems, takes under 20 seconds. Notice that this query
finds and fetches several tens of thousands of problems. Queries
that fetch only a couple of hundred of problems are executed in under 1.5 seconds.

\begin{itemize}
  \item All 2-labeling problem on undirected paths are fetched in \emph{under 0.2 sec.}
  \item All 3-labeling problem on directed paths are fetched in \emph{under 7.7 sec.}
  \item All 3-labeling problem on directed (3, 2)-biregular trees are fetched in \emph{under 20 sec.}
  \item All 3-labeling problem on directed (3, 2)-biregular trees where passive configurations are monochromatic are fetched in \emph{under 0.3 sec.}
  \item Any 3-labeling problem on undirected (3, 2)-biregular trees where passive configurations are monochromatic are fetched in \emph{under 3.2 sec.}
  \item Any 3-labeling problem on undirected (3, 2)-biregular trees where active configurations are monochromatic are fetched in \emph{under 1.1 sec.}
\end{itemize}


\section{Number of preclassified problems}

At the moment of writing the thesis, the database contains $335\,314$
LCL problems. Out of them, $197\,218$ have at least one non-trivial bound. \emph{Trivial bound} here
refers to $\Omega(1)$ for lower bounds and ``unsolvable'' for upper bounds.

The following families of LCL groups have been pre-generated batch classified
using the batch classification functionality described in Chapter~\ref{chapter:implementation}:

\begin{itemize}
  \item binary labeling problems on both directed and undericted paths and cycles
  \item ternary labeling problems on both directed and undirected paths
  \item 4-labeling problems on undirected paths
  \item binary labeling problems on both rooted and unrooted (3, 2)-biregular trees
  \item ternary labeling problems on unrooted (3, 2)-biregular trees
  \item ternary labeling problems on rooted (3, 2)-biregular trees where passive configurations are monochromatic
  \item 4-labeling problems on rooted (3, 2)-biregular trees where active configurations are monochromatic
  \item a part of 4-labeling problems on directed paths
  \item a part of ternary labeling problems on rooted (3, 2)-biregular trees (with no constraints on active or passive configurations)
  \item a part of 4-labeling problems on rooted (3, 2)-biregular trees where passive configurations are monochromatic
\end{itemize}
Notice that in all of the problem families listed above, leaf and root nodes
(or equivalently nodes of degree one on paths) are unconstrained. Moreover, in addition to the
groups of preclassified problems, the database contains several individual problems that
were added as a result of the application being used by several of the members of the
distributed algorithms research community.

Thus, it is evident that the number of preclassified problems is already at this stage sufficient
for the tool to be useful to the research community. Populating the database
with more problems of more diverse problem families is a natural opportunity for future
development.

\section{Miscellaneous}

This section contains some of the possibilities
for improving and extending the solution. The ideas collected
here has been obtained as a result of feedback
received from members of the distributed algorithms
research community who had already used the system
as part of their research process.

Currently, it is only possible to specify an upper bound for
the number of labels used in a problem when constructing a query.
A common request was to also be able to specify a lower bound for the
number of labels.

Another request was the ability to query only for those problems that are
or lead to periodic points as a result of applying round elimination.
The information about whether a problem is a periodic point ot not
is currently only available at the time of classification but is
not stored in the database. Storing the data and allowing for
querying based on it would be yet another possibility to expand the tool.

Similarly, it would be useful to query for problems based on their
exact constant complexity (as opposed to asymptotics) if such
information is available. Besides, displaying precise constant complexity
would also be benefitial when classifying a single problem.
Currently, precise constant complexity is sometimes available when
classifying a problem with the Round Eliminator. Storing this
information to the database, showing it to users and incorporating it
in the Query object would be another useful extension to the tool.

Finally, the query functionality is still currently rather limited.
Moreover, it is not clear which features of it are going to be the
most useful to the users and which will not be used often.
Thus, investigating this via collecting feedback from
research community and then modifying the tool based on
this feedback is yet another opportunity for improving the software.

