\chapter{Evaluation and opportunities for future development}
\label{chapter:evaluation}

In this chapter, we will attempt to evaluate success of our implementation
based on the research goals and the scope that we have outlined in Chapter~\ref{chapter:methods}.
Besides, we will also evaluate performance of the implementation. As seen from the title,
we have decided to combine the evaluation with discussion on opportunities for further
development. Therefore, we will also propose several ideas for how our implementation
can be improved and extended.

\section{Decidability of a wide range of problem families on trees}

The first goal among the research goals listed in Chapter~\ref{chapter:methods}
was to store (or to be able to compute dynamically) most
(if not all) of the existing knowledge on classification of LCL problems on trees.
To evaluate how well we have done, we can refer once again to Table~\ref{table:summary}.
The first three columns under the "Paths and cycles" grouping refer to LCL problems on
paths and cycles where input is not allowed. The graphs can be directed or undirected,
have arbitrary (but finite) number of labels in the output, and have restrictions
on nodes of degree 1 (in cases of paths). All of these cases are covered by
the cycle-path classifier~\cite{FIXME}, which is based on the recently
published paper~\cite{FIXME}. The classifier has been integrated into our
solution an, thus, we claim that the problems of this family are fully classifiable by our tool.
The forth column of the table refers to LCL problems on paths and cycles
where input labelling is allowed. Since none of the used classifiers
are capable of processing problems with inputs, this family of problems
has not been covered by our implementation, although it has been shown that
LCLs of this class are decidable (even though it is PSPACE-hard)~\cite{Balliu2018}.

As can be seen from the first column of the "Tree" grouping, it is unknown whether
unlabeled regular homogeneous~\cite{BalliuHomogeneous}
undirected trees are classifiable if the number of
output labels exceeds two. On the other hand, LCL problems on
unlabeled regular undirected trees with binary label output is fully decidable, albeit
only in deterministic setting. In addition to this, for some problems of the problem family,
complexity is decidable even in randomised setting~\cite{Balliu2019c}.
Since our solution does not directly include a classifier that would implement
classification of problems of the described family, our tool is not capable of
classifying the problems. It is important to notice however that the TLP
Classifier~\cite{Rocher2020clas} uses the classifier as part of its implementation.
Therefore, at least some problems of the described family can be classified. Specifically,
only problems on (2, 2)-, (2, 3)-, and (3, 2)- biregular trees of the family
(and only in deterministic setting) can be classified in our implementation.
Therefore, a natural opportunity for extending the current functionality of the tool
would be to integrate a clasifier that would classify all binary labeling LCL problems
on unlabeled regular undirected trees. Given that such implementation would
essentially involve a simple table lookup (the authors of the original paper
reduce the classification problem to a two-dimensional table lookup), the
classifier could work efficiently even with trees of relatively high degree.

The next column in the table is for LCL problems on unlabeled regular directed
trees. It has been shown that the problems of this family are fully decidable
with any finite number of output labels~\cite{Balliu2021}. However, the
only currently-existing implementation of the decidability algorithm
works exclusively with binary rooted trees~\cite{Studeny2021}. The
meta-algorithm has been successfully integrated into our solution, and
thus all LCL problems on binary rooted trees can be classified also In
practive using our tool. Nevertheless, an implementation of the
decidability algorithm that would work for trees of higher degrees
would be of high interest to the research community. The original
paper shows that such implementation for arbitrary number of output
labels is possible at least in principle. Besides, there is no
evidence that such implementation would be impractical from the
performance perspective. Therefore, a natural opportunity for
extending the software would be to build such an implementation and
consequently integrate it in our tool.

All other -- more general -- LCL problem families
are currently only known to be decidable between complexity classes of
$\Omega(\log n)$ and $O(n)$~\cite{Chang2020a}. There are currently
no known implementation of the classification algorithm described in the
referenced paper. Although the described meta-algorithm is at least
EXPTIME-hard, there is also no evidence that the algorithm wouldn't be
practical at least for a limited subfamily of problems. Therefore, its
implementation and integration into our solution would be a potential
direction for the tool's future development.

Thus, while many of the listed graph families are already classifiable
with our tool, a lot more meta-algorithms can be developed
and integrated in our solution. Moreover, the theoretical
research of decidability of LCL problems on tree is currently
developing at a high pace, which will likely bring even more
positive theoretical decidability results in the future.
It is then the task of the practitioners to catch up with
the theory and make the practical decidability landscape
as complete as possible.

\section{Finding a problem's complexity and performing group queries}

The two other goals in our list of the research goals was to

\begin{enumerate}
  \item be able to find deterministic and randomised complexity of
  of a particular problem $P$, provided that the problem belongs to
  one of the classes that one tool is capable of classifying,
  \item be able to query for groups of multiple problems based
  on a variety of parameters.
\end{enumerate}

As can be deduced from Chapter~\ref{chapter:implementation},
both of these functionalities have been succesfully implemented.
Notice that we address performance issues in another section later in
this chapter, as well as we have already evaluated the number of
problem families our tool is capable of working with. In this section,
we are discussing just the availability of the functionality, while not
being concerned with other -- although related -- metrics.
Thus, we can conclude that the two goals have been full accomplished.

\section{Querying for problem families}

% return all problems on e.g. binary rooted trees that have complexity e.g. log* N

\section{Understanding where the results come from}

% references to sources


\section{Performance}

% speed of classifying a problems

% speed of getting batch query resutls

% speed of batch classification

\section{Number of preclassified problems}

% number of preclassified problems in the database
   % how many of them are not trivially classified


\section{Miscellaneous improvements}
% currently label count is UB. People want to be able to specify a LB for labels used
% people want to query for only fixed-points problems
% people want to query for problems of exact constant complexity
% restrictions on what output nodes can produce is currently somewhat limited (at least there is no differentiation between active/passive nodes)
