@report{BalliuHomogeneous,
   author = {Alkida Balliu and Juho Hirvonen and Dennis Olivetti and Jukka Suomela},
   title = {Hardness of Minimal Symmetry Breaking in Distributed Computing},
   url = {https://dl.acm.org/doi/10.1145/3293611.3331605},
   year = {2019},
}
@book{Attiya2004,
   author = {Hagit Attiya and Jennifer Welch},
   title = {Distributed Computing: Fundamentals, Simulations, and Advanced Topics},
   url = {https://books.google.co.uk/books?hl=en&lr=&id=3xfhhRjLUJEC&oi=fnd&pg=PA7&dq=introduction+to+distributed+computing&ots=oPsAb_oQIi&sig=633aKIyjowickoXENB4CbA0CAyg#v=onepage&q=introduction%20to%20distributed%20computing&f=false},
   year = {2004},
}
@book{Lynch1996,
   author = {Nancy Lynch},
   title = {Distributed algorithms},
   url = {https://archive.org/details/distributedalgor0000lync},
   year = {1996},
}
@inproceedings{Elkin2015,
   abstract = {Graph coloring is a central problem in distributed computing. Both vertex- and edge-coloring problems have been extensively studied in this context. In this paper we show that a (2δ - l)-edge-coloring can be computed in time smaller than log<sup>∈</sup> n for any ∈ > 0, specifically, in e<sup>o</sup>(√log log n) rounds. This establishes a separation between the (2δ- l)-edge-coloring and Maximal Matching problems, as the latter is known to require ω(√log n) time [15]. No such separation is currently known between the (δ + l)-vertex-coloring and Maximal Independent Set problems. We devise a (1 + ∈)A-edge-coloring algorithm for an arbitrarily small constant ∈ > 0. This result applies whenever A > Ae, for some constant Ae which depends on e. The running time of this algorithm is O(log∗ δ +log n/δ<sup>1-0(1)</sup>). A much earlier logarithmic-time algorithm by Dubhashi, Grable and Panconesi [11] assumed δ ≥ (log n)<sup>1+ω(1)</sup>. For A = (log n) <sup>1+n(1)</sup> the running time of our algorithm is only O(log∗ n). This constitutes a drastic improvement of the previous logarithmic bound [11, 9]. Our results for (2δ - l)-edge-coloring also follows from our more general results concerning (1 - ∈)-locally sparse graphs. Specifically, we devise a (δ + l)-vertex coloring algorithm for (1 - ∈)-locally sparse graphs that runs in O(log∗ δ + log(l/e)) rounds for any ∈ > 0, provided that ∈δ = (log n)<sup>1+ω(1)</sup>. We conclude that the (δ + 1)-vertex coloring problem for (1 - ∈)-locally sparse graphs can be solved in O(log(l/∈)) + e<sup>o√loglog n</sup> time. This imply our result about (2δ - l)-edge-coloring, because (2δ - 1)-edge-coloring reduces to (δ + 1)-vertex-coloring of the line graph of the original graph, and because line graphs are (1/2 + o(1))-locally sparse.},
   author = {Michael Elkin and Seth Pettie and Hsin Hao Su},
   doi = {10.1137/1.9781611973730.26},
   issue = {January},
   journal = {Proceedings of the Annual ACM-SIAM Symposium on Discrete Algorithms},
   pages = {355-370},
   publisher = {Association for Computing Machinery},
   title = {(2δ - L)-edge-coloring is much easier than maximal matching in the distributed setting},
   volume = {2015-January},
   url = {https://epubs.siam.org/page/terms},
   year = {2015},
}
@report{Balliu2018,
   abstract = {Consider a computer network that consists of a path with n nodes. The nodes are labeled with inputs from a constant-sized set, and the task is to find output labels from a constant-sized set subject to some local constraints-more formally, we have an LCL (locally checkable labeling) problem. How many communication rounds are needed (in the standard LOCAL model of computing) to solve this problem? It is well known that the answer is always either O(1) rounds, or Θ(log * n) rounds, or Θ(n) rounds. In this work we show that this question is decidable (albeit PSPACE-hard): we present an algorithm that, given any LCL problem defined on a path, outputs the distributed computational complexity of this problem and the corresponding asymptotically optimal algorithm.},
   author = {Alkida Balliu and Sebastian Brandt and Yi-Jun Chang and Dennis Olivetti and Mikaël Rabie and Jukka Suomela},
   title = {The distributed complexity of locally checkable problems on paths is decidable},
   year = {2018},
}
@report{Fischer2017a,
   abstract = {Locally Checkable Labeling (LCL) problems include essentially all the classic problems of LOCAL distributed algorithms. In a recent enlightening revelation, Chang and Pettie [arXiv 1704.06297] showed that any LCL (on bounded degree graphs) that has an o(log n)-round randomized algorithm can be solved in T LLL (n) rounds, which is the randomized complexity of solving (a relaxed variant of) the Lovász Local Lemma (LLL) on bounded degree n-node graphs. Currently, the best known upper bound on T LLL},
   author = {Manuela Fischer},
   keywords = {()},
   title = {Sublogarithmic Distributed Algorithms for Lovász Local Lemma, and the Complexity Hierarchy Mohsen Ghaffari},
   year = {2017},
}
@article{Naor1991,
   abstract = {Suppose that n processors are arranged in a ring and can communicate only with their immediate neighbors. It is shown that any probabilistic algorithm for 3 coloring the ring must take at least $\f...},
   author = {Moni Naor},
   doi = {10.1137/0404036},
   issn = {0895-4801},
   issue = {3},
   journal = {SIAM Journal on Discrete Mathematics},
   keywords = {68M10,68Q20,68R05,68R10,distributed computation,graph coloring,probabilistic algorithms},
   month = {8},
   pages = {409-412},
   publisher = {Society for Industrial & Applied Mathematics (SIAM)},
   title = {A Lower Bound on Probabilistic Algorithms for Distributive Ring Coloring},
   volume = {4},
   year = {1991},
}
@article{Cole1986,
   abstract = {The following problem is considered: given a linked list of length n, compute the distance from each element of the linked list to the end of the list. The problem has two standard deterministic algorithms: a linear time serial algorithm, and an O(log n) time parallel algorithm using n processors. We present new deterministic parallel algorithms for the problem. Our strongest results are (1) O(log n log* n) time using n/(log n log* n) processors (this algorithm achieves optimal speed-up); (2) O(log n) time using n log(k)n/log n processors, for any fixed positive integer k. The algorithms apply a novel "random-like" deterministic technique. This technique provides for a fast and efficient breaking of an apparently symmetric situation in parallel and distributed computation. © 1986 Academic Press, Inc.},
   author = {Richard Cole and Uzi Vishkin},
   doi = {10.1016/S0019-9958(86)80023-7},
   issn = {00199958},
   issue = {1},
   journal = {Information and Control},
   month = {7},
   pages = {32-53},
   publisher = {Academic Press},
   title = {Deterministic coin tossing with applications to optimal parallel list ranking},
   volume = {70},
   year = {1986},
}
@report{Chang2016,
   abstract = {Over the past 30 years numerous algorithms have been designed for symmetry breaking problems in the LOCAL model, such as maximal matching, MIS, vertex coloring, and edge-coloring. For most problems the best randomized algorithm is at least exponentially faster than the best deterministic algorithm. In this paper we prove that these exponential gaps are necessary and establish numerous connections between the deterministic and randomized complexities in the LOCAL model. Each of our results has a very compelling takeaway message: Fast ∆-coloring of trees requires random bits. Building on the recent randomized lower bounds of Brandt et al. [11], we prove that the randomized complexity of ∆-coloring a tree with maximum degree ∆ is Θ(log ∆ log n), for any ∆ ≥ 55, whereas its deterministic complexity is Θ(log ∆ n) for any ∆ ≥ 3. 1 This also establishes a large separation between the deterministic complexity of ∆-coloring and (∆ + 1)-coloring trees. Randomized lower bounds imply deterministic lower bounds. We prove that any deterministic algorithm for a natural class of problems that runs in O(1) + o(log ∆ n) rounds can be transformed to run in O(log * n − log * ∆ + 1) rounds. If the transformed algorithm violates a lower bound (even allowing randomization), then one can conclude that the problem requires Ω(log ∆ n) time deterministically. (This gives an alternate proof that deterministically ∆-coloring a tree with small ∆ takes Ω(log ∆ n) rounds.) Deterministic lower bounds imply randomized lower bounds. We prove that the randomized complexity of any natural problem on instances of size n is at least its deterministic complexity on instances of size √ log n. This shows that a deterministic Ω(log ∆ n) lower bound for any problem (∆-coloring a tree, for example) implies a randomized Ω(log ∆ log n) lower bound. It also illustrates that the graph shattering technique employed in recent randomized symmetry breaking algorithms is absolutely essential to the LOCAL model. For example, it is provably impossible to improve the 2 O(√ log log n) terms in the complexities of the best MIS and (∆ + 1)-coloring algorithms without also improving the 2 O(√ log n)-round Panconesi-Srinivasan algorithms.},
   author = {Yi-Jun Chang and Tsvi Kopelowitz and Seth Pettie},
   isbn = {1602.08166v2},
   keywords = {()},
   title = {An Exponential Separation Between Randomized and Deterministic Complexity in the LOCAL Model},
   year = {2016},
}
@report{Balliu2016,
   abstract = {A number of recent papers-e.g. Brandt et al.have advanced our understanding of one of the most fundamental questions in theory of distributed computing: what are the possible time complexity classes of LCL problems in the LOCAL model? In essence, we have a graph problem Π in which a solution can be verified by checking all radius-O(1) neighbourhoods, and the question is what is the smallest T such that a solution can be computed so that each node chooses its own output based on its radius-T neighbourhood. Here T is the distributed time complexity of Π. The time complexity classes for deterministic algorithms in bounded-degree graphs that are known to exist by prior work are Θ(1), Θ(log * n), Θ(log n), Θ(n 1/k), and Θ(n). It is also known that there are two gaps: one between ω(1) and o(log log * n), and another between ω(log * n) and o(log n). It has been conjectured that many more gaps exist, and that the overall time hierarchy is relatively simple-indeed, this is known to be the case in restricted graph families such as cycles and grids. We show that the picture is much more diverse than previously expected. We present a general technique for engineering LCL problems with numerous different deterministic time complexities, including Θ(log α n) for any α ≥ 1, 2 Θ(log α n) for any α ≤ 1, and Θ(n α) for any α < 1/2 in the high end of the complexity spectrum, and Θ(log α log * n) for any α ≥ 1, 2 Θ(log α log * n) for any α ≤ 1, and Θ((log * n) α) for any α ≤ 1 in the low end of the complexity spectrum; here α is a positive rational number.},
   author = {Alkida Balliu and Juho Hirvonen and Janne H Korhonen and Dennis Olivetti and Jukka Suomela},
   title = {New Classes of Distributed Time Complexity},
   year = {2016},
}
@report{Balliu2020-1,
   abstract = {The landscape of the distributed time complexity is nowadays well-understood for subpolyno-mial complexities. When we look at deterministic algorithms in the LOCAL model and locally checkable problems (LCLs) in bounded-degree graphs, the following picture emerges: There are lots of problems with time complexities of Θ(log * n) or Θ(log n). It is not possible to have a problem with complexity between ω(log * n) and o(log n). In general graphs, we can construct LCL problems with infinitely many complexities between ω(log n) and n o(1). In trees, problems with such complexities do not exist. However, the high end of the complexity spectrum was left open by prior work. In general graphs there are LCL problems with complexities of the form Θ(n α) for any rational 0 < α ≤ 1/2, while for trees only complexities of the form Θ(n 1/k) are known. No LCL problem with complexity between ω(√ n) and o(n) is known, and neither are there results that would show that such problems do not exist. We show that: In general graphs, we can construct LCL problems with infinitely many complexities between ω(√ n) and o(n). In trees, problems with such complexities do not exist. Put otherwise, we show that any LCL with a complexity o(n) can be solved in time O(√ n) in trees, while the same is not true in general graphs.},
   author = {Alkida Balliu and Sebastian Brandt and Dennis Olivetti and Jukka Suomela},
   keywords = {2012 ACM Subject Classification Theory of computation → Distributed computing models,LOCAL model,Theory of computation → Complexity classes Keywords and phrases Distributed complexity theory,locally checkable labellings},
   title = {Almost Global Problems in the LOCAL Model},
   year = {2020},
}
@inproceedings{Balliu2020-2,
   abstract = {Locally checkable labeling problems (LCLs) are distributed graph problems in which a solution is globally feasible if it is locally feasible in all constant-radius neighborhoods. Vertex colorings, maximal independent sets, and maximal matchings are examples of LCLs. On the one hand, it is known that some LCLs benefit exponentially from randomness - -for example, any deterministic distributed algorithm that finds a sinkless orientation requires Θ(log n) rounds in the LOCAL model, while the randomized complexity of the problem is Θ(log log n) rounds. On the other hand, there are also many LCLs in which randomness is useless. Previously, it was not known whether there are any LCLs that benefit from randomness, but only subexponentially. We show that such problems exist: for example, there is an LCL with deterministic complexity Θ(log2 n) rounds and randomized complexity Θ(log n log log n) rounds.},
   author = {Alkida Balliu and Sebastian Brandt and Dennis Olivetti and Jukka Suomela},
   city = {New York, NY, USA},
   doi = {10.1145/3382734.3405715},
   isbn = {9781450375825},
   journal = {Proceedings of the Annual ACM Symposium on Principles of Distributed Computing},
   keywords = {LOCAL model,distributed computational complexity,locally checkable labeling problems},
   month = {7},
   pages = {299-308},
   publisher = {Association for Computing Machinery},
   title = {How much does randomness help with locally checkable problems?},
   url = {https://dl.acm.org/doi/10.1145/3382734.3405715},
   year = {2020},
}
@book{Hirvonen2020,
   author = {Juho Hirvonen and Jukka Suomela},
   title = {Distributed Algorithms 2020},
   url = {https://jukkasuomela.fi/da2020/},
   year = {2020},
}
@book{Wattenhofer2016,
   author = {Roger Wattenhofer},
   title = {Principles of Distributed Computing},
   year = {2016},
}
@report{Ghaffari2020,
   author = {Mohsen Ghaffari and Fabian Kuhn},
   title = {Deterministic Distributed Vertex Coloring: Simpler, Faster, and without Network Decomposition},
   year = {2020},
}
@inproceedings{Chang2019,
   abstract = {The complexity of distributed edge coloring depends heavily on the palette size as a function of the maximum degree Δ. In this article, we explore the complexity of edge coloring in the LOCAL model in different palette size regimes. Our results are as follows. Lower Bounds: First, we simplify the round elimination technique of Brandt et al. [16] and prove that (2Δ - 2)-edge coloring requires Ω(logΔ logn) time with high probability and Ω(logΔ n) time deterministically, even on trees. Second, we show that a natural approach to computing (Δ + 1)-edge colorings (Vizing's theorem), namely, extending an arbitrary partial coloring by iteratively recoloring subgraphs, requires Ω(Δlogn) time. Upper Bounds on General Graphs: We give a randomized edge coloring algorithm that can use palette sizes as small as Δ + O ( √ Δ), which is a natural barrier for randomized approaches. The running time of our (1 + ∈)Δ-edge coloring algorithm is usually dominated by O(log ∈ -1) calls to a distributed Lovasz local lemma (LLL) algorithm. For example, using the Chung-Pettie-Su LLL algorithm, we compute a (1 + ∈)Δ-edge coloring in O(logn) time when ∈ ≥ (log3 Δ)/ √ Δ, or O(logΔ n) + (log logn)3+o(1) time when ∈ = Ω(1). When Δ is sublogarithmic in n the performance is improved with the Ghaffari-Harris-Kuhn LLL algorithm. Upper Bounds on Trees: We show that the Ω(logΔ logn) lower bound can be nearly matched on trees. To establish this result, we develop a new distributed Lovasz local lemma algorithm for tree-structured dependency graphs, which arise naturally from O(1)-round probabilistic algorithms run on trees. Specifically, our (1 + ∈)Δ-edge coloring algorithm for trees takes O(log(1/∈ )) max\{ log log n log log log n , loglog Δ logn\} time when∈ ≥ (log3 Δ)/ √ Δ, orO(max\{ log log n log log log n , logΔ logn\}) time when ∈ = Ω(1).},
   author = {Yi Jun Chang and Qizheng He and Wenzheng Li and Seth Pettie and Jara Uitto},
   doi = {10.1145/3365004},
   issn = {15496333},
   issue = {1},
   journal = {ACM Transactions on Algorithms},
   keywords = {Distributed algorithms,Edge coloring,LOCAL model,Lovasz local lemma},
   month = {11},
   pages = {1-51},
   publisher = {Association for Computing Machinery},
   title = {Distributed edge coloring and a special case of the constructive lovász local lemma},
   volume = {16},
   url = {https://dl.acm.org/doi/10.1145/3365004},
   year = {2019},
}
@report{,
   abstract = {The problem of coloring the edges of an n-node graph of maximum degree ∆ with 2∆ − 1 colors is one of the key symmetry breaking problems in the area of distributed graph algorithms. While there has been a lot of progress towards the understanding of this problem, the dependency of the running time on ∆ has been a long-standing open question. Very recently, Kuhn [SODA '20] showed that the problem can be solved in time 2 O(√ log ∆) + O(log * n). In this paper, we study the edge coloring problem in the distributed LOCAL model. We show that the (degree + 1)-list edge coloring problem, and thus also the (2∆ − 1)-edge coloring problem, can be solved deterministically in time log O(log log ∆) ∆ + O(log * n). This is a significant improvement over the result of Kuhn [SODA '20].},
   author = {Alkida Balliu and Fabian Kuhn and Dennis Olivetti},
   title = {Distributed Edge Coloring in Time Quasi-Polylogarithmic in Delta},
}
@report{Chang2020a,
   abstract = {Recent research revealed the existence of gaps in the complexity landscape of locally checkable labeling (LCL) problems in the LOCAL model of distributed computing. For example, the de-terministic round complexity of any LCL problem on bounded-degree graphs is either O(log * n) or Ω(log n) [Chang, Kopelowitz, and Pettie, FOCS 2016]. The complexity landscape of LCL problems is now quite well-understood, but a few questions remain open. For bounded-degree trees, there is an LCL problem with round complexity Θ(n 1/k) for each positive integer k [Chang and Pettie, FOCS 2017]. It is conjectured that no LCL problem has round complexity o(n 1/(k−1)) and ω(n 1/k) on bounded-degree trees. As of now, only the case of k = 2 has been proved [Balliu et al., DISC 2018]. In this paper, we show that for LCL problems on bounded-degree trees, there is indeed a gap between Θ(n 1/(k−1)) and Θ(n 1/k) for each k ≥ 2. Our proof is constructive in the sense that it offers a sequential algorithm that decides which side of the gap a given LCL problem belongs to. We also show that it is EXPTIME-hard to distinguish between Θ(1)-round and Θ(n)-round LCL problems on bounded-degree trees. This improves upon a previous PSPACE-hardness result [Balliu et al., PODC 2019].},
   author = {Yi-Jun Chang},
   title = {The Complexity Landscape of Distributed Locally Checkable Problems on Trees},
   year = {2020},
}
@article{Panconesi2001,
   abstract = {We give simple, deterministic, distributed algorithms for computing maximal matchings, maximal independent sets and colourings. We show that edge colourings with at most 2Δ - 1 colours, and maximal matchings can be computed within O(log* n + Δ) deterministic rounds, where Δ is the maximum degree of the network. We also show how to find maximal independent sets and (Δ + 1)-vertex colourings within O(log* n + Δ2) deterministic rounds. All hidden constants are very small and the algorithms are very simple.},
   author = {Alessandro Panconesi and Romeo Rizzi},
   doi = {10.1007/PL00008932},
   issn = {01782770},
   issue = {2},
   journal = {Distributed Computing},
   keywords = {Distributed computing,Edge colouring,Maximal independent set,Maximal matching,Sparse networks,Vertex colouring},
   month = {4},
   pages = {97-100},
   publisher = {
		Springer-Verlag
		PUB3755
		Berlin, Heidelberg
	},
   title = {Some simple distributed algorithms for sparse networks},
   volume = {14},
   url = {http://link.springer.com/10.1007/PL00008932},
   year = {2001},
}
@report{Fischer2017b,
   author = {Manuela Fischer},
   isbn = {1703.00900v2},
   title = {Improved Deterministic Distributed Matching via Rounding},
   year = {2017},
}
@article{Rozhon2019,
   abstract = {We present a simple polylogarithmic-time deterministic distributed algorithm for network decomposition. This improves on a celebrated $2^\{O(\sqrt\{\log n\})\}$-time algorithm of Panconesi and Srinivasan [STOC'92] and settles a central and long-standing question in distributed graph algorithms. It also leads to the first polylogarithmic-time deterministic distributed algorithms for numerous other problems, hence resolving several well-known and decades-old open problems, including Linial's question about the deterministic complexity of maximal independent set [FOCS'87; SICOMP'92]---which had been called the most outstanding problem in the area. The main implication is a more general distributed derandomization theorem: Put together with the results of Ghaffari, Kuhn, and Maus [STOC'17] and Ghaffari, Harris, and Kuhn [FOCS'18], our network decomposition implies that $$\mathsf\{P\}\textit\{-\}\mathsf\{RLOCAL\} = \mathsf\{P\}\textit\{-\}\mathsf\{LOCAL\}.$$ That is, for any problem whose solution can be checked deterministically in polylogarithmic-time, any polylogarithmic-time randomized algorithm can be derandomized to a polylogarithmic-time deterministic algorithm. Informally, for the standard first-order interpretation of efficiency as polylogarithmic-time, distributed algorithms do not need randomness for efficiency. By known connections, our result leads also to substantially faster randomized distributed algorithms for a number of well-studied problems including $(\Delta+1)$-coloring, maximal independent set, and Lov\'\{a\}sz Local Lemma, as well as massively parallel algorithms for $(\Delta+1)$-coloring.},
   author = {Mohsen Ghaffari},
   journal = {Proceedings of the Annual ACM Symposium on Theory of Computing},
   keywords = {Derandomization,Distributed algorithms,Network decomposition},
   month = {7},
   pages = {350-363},
   publisher = {Association for Computing Machinery},
   title = {Polylogarithmic-Time Deterministic Network Decomposition and Distributed Derandomization},
   url = {http://arxiv.org/abs/1907.10937},
   year = {2019},
}
@inproceedings{Balliu2019,
   abstract = {There are distributed graph algorithms for finding maximal matchings and maximal independent sets in O(Δ + log∗ n) communication rounds; here n is the number of nodes and Δ is the maximum degree. The lower bound by Linial (1987, 1992) shows that the dependency on n is optimal: These problems cannot be solved in o(log∗ n) rounds even if Δ = 2. However, the dependency on Δ is a long-standing open question, and there is currently an exponential gap between the upper and lower bounds. We prove that the upper bounds are tight. We show that maximal matchings and maximal independent sets cannot be found in o(Δ + log log n / log log log n) rounds with any randomized algorithm in the LOCAL model of distributed computing. As a corollary, it follows that there is no deterministic algorithm for maximal matchings or maximal independent sets that runs in o(Δ + log n / log log n) rounds; this is an improvement over prior lower bounds also as a function of n.},
   author = {Alkida Balliu and Sebastian Brandt and Juho Hirvonen and Dennis Olivetti and Mikael Rabie and Jukka Suomela},
   doi = {10.1109/FOCS.2019.00037},
   isbn = {9781728149523},
   issn = {02725428},
   journal = {Proceedings - Annual IEEE Symposium on Foundations of Computer Science, FOCS},
   keywords = {Maximal matching,distributed graph algorithms,lower bounds,maximal independent set},
   month = {11},
   pages = {481-497},
   publisher = {IEEE Computer Society},
   title = {Lower Bounds for Maximal Matchings and Maximal Independent Sets},
   volume = {2019-November},
   year = {2019},
}
@web_page{Suomela2020,
   author = {Jukka Suomela},
   title = {Landscape of Locality},
   url = {https://jukkasuomela.fi/landscape-of-locality/},
   year = {2020},
}
@web_page{Rocher2020doc,
   author = {Tanguy Rocher},
   title = {GitHub - trocher/tlpDoc},
   url = {https://github.com/trocher/tlpDoc},
   year = {2020},
}
@web_page{Rocher2020clas,
   author = {Tanguy Rocher},
   title = {GitHub - trocher/tlpClassifier},
   url = {https://github.com/trocher/tlpClassifier},
   year = {2020},
}
@web_page{Tereshchenko2020,
   author = {Aleksandr Tereshchenko},
   title = {Cyclepath classifier},
   url = {https://github.com/AleksTeresh/cyclepath-classifier},
   year = {2020},
}
@web_page{Tereshchenko2020brt,
   author = {Aleksandr Tereshchenko},
   title = {Tree classifications},
   url = {https://github.com/AleksTeresh/tree-classifications},
   year = {2020},
}
@article{Chang2020,
   abstract = {The locality of a graph problem is the smallest distance $T$ such that each node can choose its own part of the solution based on its radius-$T$ neighborhood. In many settings, a graph problem can be solved efficiently with a distributed or parallel algorithm if and only if it has a small locality. In this work we seek to automate the study of solvability and locality: given the description of a graph problem $\Pi$, we would like to determine if $\Pi$ is solvable and what is the asymptotic locality of $\Pi$ as a function of the size of the graph. Put otherwise, we seek to automatically synthesize efficient distributed and parallel algorithms for solving $\Pi$. We focus on locally checkable graph problems; these are problems in which a solution is globally feasible if it looks feasible in all constant-radius neighborhoods. Prior work on such problems has brought primarily bad news: questions related to locality are undecidable in general, and even if we focus on the case of labeled paths and cycles, determining locality is $\mathsf\{PSPACE\}$-hard (Balliu et al., PODC 2019). We complement prior negative results with efficient algorithms for the cases of unlabeled paths and cycles and, as an extension, for rooted trees. We introduce a new automata-theoretic perspective for studying locally checkable graph problems. We represent a locally checkable problem $\Pi$ as a nondeterministic finite automaton $\mathcal\{M\}$ over a unary alphabet. We identify polynomial-time-computable properties of the automaton $\mathcal\{M\}$ that near-completely capture the solvability and locality of $\Pi$ in cycles and paths, with the exception of one specific case that is $\mbox\{co-$\mathsf\{NP\}$\}$-complete.},
   author = {Yi-Jun Chang and Jan Studený and Jukka Suomela},
   month = {2},
   title = {Distributed graph problems through an automata-theoretic lens},
   url = {http://arxiv.org/abs/2002.07659},
   year = {2020},
}
@article{Balliu2019c,
   abstract = {We present a complete classification of the deterministic distributed time complexity for a family of graph problems: binary labeling problems in trees. These are locally checkable problems that can be encoded with an alphabet of size two in the edge labeling formalism. Examples of binary labeling problems include sinkless orientation, sinkless and sourceless orientation, 2-vertex coloring, perfect matching, and the task of coloring edges red and blue such that all nodes are incident to at least one red and at least one blue edge. More generally, we can encode e.g. any cardinality constraints on indegrees and outdegrees. We study the deterministic time complexity of solving a given binary labeling problem in trees, in the usual LOCAL model of distributed computing. We show that the complexity of any such problem is in one of the following classes: $O(1)$, $\Theta(\log n)$, $\Theta(n)$, or unsolvable. In particular, a problem that can be represented in the binary labeling formalism cannot have time complexity $\Theta(\log^* n)$, and hence we know that e.g. any encoding of maximal matchings has to use at least three labels (which is tight). Furthermore, given the description of any binary labeling problem, we can easily determine in which of the four classes it is and what is an asymptotically optimal algorithm for solving it. Hence the distributed time complexity of binary labeling problems is decidable, not only in principle, but also in practice: there is a simple and efficient algorithm that takes the description of a binary labeling problem and outputs its distributed time complexity.},
   author = {Alkida Balliu and Sebastian Brandt and Yuval Efron and Juho Hirvonen and Yannic Maus and Dennis Olivetti and Jukka Suomela},
   keywords = {Aalto,Efron · szxrtde@cstechnionacil ·,Hirvonen · juhohirvonen@aaltofi ·,Juho,Maus · yannicmaus@campustechnionacil ·,Technion,University,Yannic,Yuval},
   month = {11},
   title = {Classification of distributed binary labeling problems},
   url = {http://arxiv.org/abs/1911.13294},
   year = {2019},
}
@article{Balliu2021,
  author          = {Alkida Balliu and Sebastian Brandt and Dennis Olivetti and Jan Studený and Jukka Suomela and Aleksandr Tereshchenko},
  title           = {Locally Checkable Problems in Rooted Trees},
  year            = {2021}
}
@web_page{Olivetti2020,
   author = {Dennis Olivetti},
   title = {Round Eliminator: a tool for automatic speedup simulation},
   url = {https://github.com/olidennis/round-eliminator},
   year = {2020},
}
@web_page{Studeny2021,
   author = {Jan Studený and Aleksandr Tereshchenko},
   title = {Rooted tree classifier},
   url = {https://github.com/jendas1/rooted-tree-classifier},
   year = {2021},
}
@web_page{CPython,
   title = {The Python programming language},
   url = {https://github.com/python/cpython},
   author = {Guido van Rossum and Benjamin Peterson
 and Georg Brandl and Fred Drake and Victor Stinner and Raymond Hettinger and Serhiy Storchaka}
}
@web_page{stdio,
   title = {stdio -- standard input/output library functions},
   url = {https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/stdio.3.html},
}
@web_page{WASM,
   title = {WebAssembly},
   url = {https://webassembly.org/}
}
@web_page{RustCPython,
   title = {Rust to CPython bindings},
   url = {https://github.com/dgrunwald/rust-cpython},
}
@web_page{Rust,
   title = {Rust programming language},
   url = {https://www.rust-lang.org/},
}
@web_page{Cargo,
   title = {crates.io: Rust Package Registry},
   url = {https://crates.io/}
}
@web_page{TypeScript,
   title = {TypeScript: Typed JavaScrippt at Any Scale},
   url = {https://www.typescriptlang.org/}
}
@web_page{Svelte,
   title = {Svelte},
   url = {https://svelte.dev/}
}
@web_page{Milligram,
   title = {Milligram - A minimalist CSS framework},
   url = {https://milligram.io/}
}
@web_page{SvelteVsReactBundleSize,
   title = {Will it Scale? - Finding Svelte's Inflection Point},
   url = {https://github.com/halfnelson/svelte-it-will-scale/blob/master/README.md}
}
@web_page{svelte-virtual-list,
   title = {A virtual list component for Svelte apps},
   url = {https://github.com/sveltejs/svelte-virtual-list},
   author = {Rich Harris and Jacob Wright and Michael Keller}
}
@inproceedings{BFHKLRSU16,
  author = {Brandt, Sebastian and Fischer, Orr and Hirvonen, Juho and Keller, Barbara and Lempi{\"a}inen, Tuomo and Rybicki, Joel and Suomela, Jukka and Uitto, Jara},
  title = {A lower bound for the distributed {L}ov{\'a}sz local lemma},
  year = {2016},
  pages = {479--488},
  doi = {10.1145/2897518.2897570},
  eprint = {1511.00900},
  publisher = {ACM Press},
  booktitle = {Proc.\ 48th ACM Symposium on Theory of Computing (STOC 2016)}
}
@inproceedings{Brandt2019,
   abstract = {Recently, Brandt et al. [STOC'16] proved a lower bound for the distributed Lovasz Local Lemma, which has been conjectured to be tight for sufficiently relaxed LLL criteria by Chang and Pettie [FOCS'17]. At the heart of their result lies a speedup technique that, for graphs of girth at least 2t +2, transforms any t -round algorithm for one specific LLL problem into a (t - 1)-round algorithm for the same problem. We substantially improve on this technique by showing that such a speedup exists for any locally checkable problem ∏, with the difference that the problem ∏1 the inferred (t .1)-round algorithm solves is not (necessarily) the same problem as ∏. Our speedup is automatic in the sense that there is a fixed procedure that transforms a description for ∏ into a description for ∏1 and reversible in the sense that any (t - 1)-round algorithm for ∏1 can be transformed into a t -round algorithm for ∏. In particular, for any locally checkable problem ∏ with exact deterministic time complexity T (n, δ) ≤ t on graphs with n nodes, maximum node degree δ, and girth at least 2t + 2, there is a sequence of problems ∏1, ∏2, ⋯ with time complexities T (n, δ) . 1,T (n, δ) - 2, ⋯ , that can be inferred from ∏. As a first application of our generalized speedup, we solve a longstanding open problem of Naor and Stockmeyer [STOC'93]: we show that weak 2-coloring in odd-degree graphs cannot be solved in o(log.δ) rounds, thereby providing a matching lower bound to their upper bound.},
   author = {Sebastian Brandt},
   city = {New York, NY, USA},
   doi = {10.1145/3293611.3331611},
   isbn = {9781450362177},
   journal = {Proceedings of the Annual ACM Symposium on Principles of Distributed Computing},
   keywords = {Distributed graph algorithms,Locally checkable problems,Weak coloring},
   month = {7},
   pages = {379-388},
   publisher = {Association for Computing Machinery},
   title = {An automatic speedup theorem for distributed problems},
   url = {https://dl.acm.org/doi/10.1145/3293611.3331611},
   year = {2019},
}
@inproceedings{Naor1993,
   abstract = {The purpose of this paper is a study of computation that can be done locally in a distributed network. By locally we mean within time (or distance) independent of the size of the network. We consider Locally Checkable Labeling (LCL) problems, where the legality of a labeling can be checked locally (e.g., coloring). Our results include the following: .There are non-Trivial LCL problems that have local algorithms. There is a variant of the dining philosophers problem which can be solved locally. Randomization cannot make an LCL problem local; i.e., if a problem has a local randomized algorithm then it has a local deterministic algorithm. It is undecidable, in general, whether a given LCL has a local algorithm. However, it is decidable whether a given LCL has an algorithm that operates in a given time t. Any LCL problem that has a local algorithm has one which is order-invariant (the algorithm depends only on the order of the processor id's).},
   author = {Moni Naor and Larry Stockmeyer},
   city = {New York, New York, USA},
   doi = {10.1145/167088.167149},
   isbn = {0897915917},
   issn = {07378017},
   journal = {Proceedings of the Annual ACM Symposium on Theory of Computing},
   month = {6},
   pages = {184-193},
   publisher = {Association for Computing Machinery},
   title = {What can be computed locally?},
   volume = {Part F129585},
   url = {http://portal.acm.org/citation.cfm?doid=167088.167149},
   year = {1993},
}
@article{Linial1992,
   abstract = {This paper concerns a number of algorithmic problems on graphs and how they may be solved in a distributed fashion. The computational model is such that each node of the graph is occupied by a processor which has its own ID. Processors are restricted to collecting data from others which are at a distance at most t away from them in t time units, but are otherwise computationally unbounded. This model focuses on the issue of locality in distributed processing, namely, to what extent a global solution to a computational problem can be obtained from locally available data. Three results are proved within this model. A 3-coloring of an n-cycle requires time Ω(log n). This bound is tight, by previous work of Cole and Vishkin. Any algorithm for coloring the d-regular tree of radius r which runs for time at most 2τ/3 requires at least Ω(√d) colors. In an n-vortex graph of largest degree Δ, O(Δ2)-coloring may be found in time O(log n).},
   author = {Nathan Linial},
   doi = {10.1137/0221015},
   issn = {00975397},
   issue = {1},
   journal = {SIAM Journal on Computing},
   keywords = {05C35,68Q99,68R10,distributed algorithms,graph theory,locality,lower bounds},
   month = {7},
   pages = {193-201},
   publisher = {Society for Industrial and Applied Mathematics},
   title = {Locality in distributed graph algorithms},
   volume = {21},
   year = {1992},
}
@inproceedings{Linial1987,
   abstract = {Processors that reside in the vertices of a graph G and communicate only with their neighbors are considered. The system is synchronous and reliable, there is not limit on message lengths, and local computation is instantaneous. It is shown that a maximal independent set in an n-cycle cannot be found faster than OMEGA (log***n), and this is optimal. The d-regular tree of radius r cannot be colored with fewer than ROOT d colors in time 2r/3. If DELTA is the largest degree in G which has order n, then in time O(log*n) it can be colored with O( DELTA **2) colors.},
   author = {Nathan Linial},
   doi = {10.1109/sfcs.1987.20},
   isbn = {0818608072},
   issn = {02725428},
   journal = {Annual Symposium on Foundations of Computer Science (Proceedings)},
   pages = {331-335},
   publisher = {IEEE},
   title = {DISTRIBUTIVE GRAPH ALGORITHMS-GLOBAL SOLUTIONS FROM LOCAL DATA.},
   year = {1987},
}

@book{Sipser2012,
   author = {Michael Sipser},
   edition = {3rd},
   title = {Introduction to the Theory of Computation},
   url = {https://notendur.hi.is/mae46/Haskolinn/5.%20misseri%20-%20Haust%202018/Formleg%20ma%CC%81l%20og%20reiknanleiki/Introduction%20to%20the%20theory%20of%20computation_third%20edition%20-%20Michael%20Sipser.pdf},
   year = {2012},
}
@article{Turing1937,
   author = {A. M. Turing},
   doi = {10.1112/plms/s2-42.1.230},
   issn = {1460244X},
   issue = {1},
   journal = {Proceedings of the London Mathematical Society},
   month = {1},
   pages = {230-265},
   publisher = {Oxford University Press (OUP)},
   title = {On computable numbers, with an application to the entscheidungsproblem},
   volume = {s2-42},
   url = {http://doi.wiley.com/10.1112/plms/s2-42.1.230},
   year = {1937},
}
@article{Margenstern2000,
   abstract = {After recalling the definition of decidability and universality, we first give a survey of results on the as exact as possible border betweeen a decidable problem and the corresponding undecidablity question in various models of discrete computation: diophantine equations, word problem, Post systems, molecular computations, register machines, neural networks, cellular automata, tiling the plane and Turing machines with planar tape. We then go on with results more specific to classical Turing machines, with a survey of results and a sketchy account on technics. We conclude by an illustration on simulating the 3x + 1 problem. © 2000 Elsevier Science B.V. All rights reserved.},
   author = {Maurice Margenstern},
   doi = {10.1016/S0304-3975(99)00102-4},
   issn = {03043975},
   issue = {2},
   journal = {Theoretical Computer Science},
   keywords = {Decidability versus undecidability,Discrete computations,Halting problem,Universality},
   month = {1},
   pages = {217-251},
   publisher = {Elsevier},
   title = {Frontier between decidability and undecidability: A survey},
   volume = {231},
   year = {2000},
}

@article{auto-class_Sharma2017,
   abstract = {Deep learning using convolutional neural networks is an actively emerging field in histological image analysis. This study explores deep learning methods for computer-aided classification in H&E stained histopathological whole slide images of gastric carcinoma. An introductory convolutional neural network architecture is proposed for two computerized applications, namely, cancer classification based on immunohistochemical response and necrosis detection based on the existence of tumor necrosis in the tissue. Classification performance of the developed deep learning approach is quantitatively compared with traditional image analysis methods in digital histopathology requiring prior computation of handcrafted features, such as statistical measures using gray level co-occurrence matrix, Gabor filter-bank responses, LBP histograms, gray histograms, HSV histograms and RGB histograms, followed by random forest machine learning. Additionally, the widely known AlexNet deep convolutional framework is comparatively analyzed for the corresponding classification problems. The proposed convolutional neural network architecture reports favorable results, with an overall classification accuracy of 0.6990 for cancer classification and 0.8144 for necrosis detection.},
   author = {Harshita Sharma and Norman Zerbe and Iris Klempert and Olaf Hellwich and Peter Hufnagl},
   doi = {10.1016/j.compmedimag.2017.06.001},
   issn = {18790771},
   journal = {Computerized Medical Imaging and Graphics},
   keywords = {Cancer classification,Convolutional neural networks,Deep learning,Digital pathology,Gastric carcinoma,Histopathological image analysis,Necrosis detection},
   month = {11},
   pages = {2-13},
   pmid = {28676295},
   publisher = {Elsevier Ltd},
   title = {Deep convolutional neural networks for automatic classification of gastric carcinoma using whole slide images in digital histopathology},
   volume = {61},
   year = {2017},
}
@inproceedings{auto-class_Capizzi2015,
   abstract = {Nowadays the effective and fast detection of fruit defects is one of the main concerns for fruit selling companies. This paper presents a new approach that classifies fruit surface defects in color and texture using Radial Basis Probabilistic Neural Networks (RBPNN). The texture and gray features of defect area are extracted by computing a gray level co-occurrence matrix and then defect areas are classified by the applied RBPNN solution.},
   author = {Giacomo Capizzi and Grazia Lo Sciuto and Christian Napoli and Emiliano Tramontana and Marcin Wozniak},
   doi = {10.15439/2015F258},
   isbn = {9788360810651},
   journal = {Proceedings of the 2015 Federated Conference on Computer Science and Information Systems, FedCSIS 2015},
   keywords = {Co-occurrence matrix,Pattern recognition,Probabilistic neural network,Texture analysis},
   pages = {861-867},
   publisher = {Institute of Electrical and Electronics Engineers Inc.},
   title = {Automatic classification of fruit defects based on Co-occurrence matrix and neural networks},
   year = {2015},
}
@article{auto-class_Ibrahim2018,
   abstract = {In this paper, the effectiveness of deep learning for automatic classification of grouper species by their vocalizations has been investi- gated. In the proposed approach, wavelet denoising is used to reduce ambient ocean noise, and a deep neural network is then used to classify sounds generated by different species of groupers. Experimental results for four species of groupers show that the proposed approach achieves a classification accuracy of around 90% or above in all of the tested cases, a result that is significantly better than the one obtained by a previously reported method for automatic classification of grouper calls.},
   author = {Ali K. Ibrahim and Hanqi Zhuang and Laurent M. Chérubin and Michelle T. Schärer-Umpierre and Nurgun Erdol},
   doi = {10.1121/1.5054911},
   issn = {0001-4966},
   issue = {3},
   journal = {The Journal of the Acoustical Society of America},
   month = {9},
   pages = {EL196-EL202},
   pmid = {30424627},
   publisher = {Acoustical Society of America (ASA)},
   title = {Automatic classification of grouper species by their sounds using deep neural networks},
   volume = {144},
   url = {http://asa.scitation.org/doi/10.1121/1.5054911},
   year = {2018},
}
@inproceedings{auto-class_Colonna2016,
   abstract = {Anurans (frogs or toads) are closely related to the ecosystem and they are commonly used by biologists as early indicators of ecological stress. Automatic classification of anurans, by processing their calls, helps biologists analyze the activity of anurans on larger scale. Wireless Sensor Networks (WSNs) can be used for gathering data automatically over a large area. WSNs usually set restrictions on computing and transmission power for extending the network's lifetime. Deep Learning algorithms have gathered a lot of popularity in recent years, especially in the field of image recognition. Being an eager learner, a trained Deep Learning model does not need a lot of computing power and could be used in hardware with limited resources. This paper investigates the possibility of using Convolutional Neural Networks with Mel-Frequency Cepstral Coefficients (MFCCs) as input for the task of classifying anuran sounds.},
   author = {Juan Colonna and Tanel Peet and Carlos Abreu Ferreira and Alípio M. Jorge and Elsa Ferreira Gomes and João Gama},
   city = {New York, New York, USA},
   doi = {10.1145/2948992.2949016},
   isbn = {9781450340755},
   journal = {ACM International Conference Proceeding Series},
   keywords = {Anurans,Convolutional neural networks,MFCC,Machine learning,Wireless sensor networks},
   month = {7},
   pages = {73-78},
   publisher = {Association for Computing Machinery},
   title = {Automatic classification of anuran sounds using convolutional neural networks},
   volume = {20-22-July-2016},
   url = {http://dl.acm.org/citation.cfm?doid=2948992.2949016},
   year = {2016},
}
@inproceedings{auto-class_Winkler2017,
   abstract = {The results of the requirements engineering process are predominantly documented in natural language requirements specifications. Besides the actual requirements, these documents contain additional content such as explanations, summaries, and figures. For the later use of requirements specifications, it is important to be able to differentiate between legally relevant requirements and other auxiliary content. Therefore, one of our industry partners demands the requirements engineers to manually label each content element of a requirements specification as 'requirement' or 'information'. However, this manual labeling task is time-consuming and error-prone. In this paper, we present an approach to automatically classify content elements of a natural language requirements specification as 'requirement' or 'information'. Our approach uses convolutional neural networks. In an initial evaluation on a real-world automotive requirements specification, our approach was able to detect requirements with a precision of 0.73 and a recall of 0.89. The approach increases the quality of requirements specifications in the sense that it discriminates important content for following activities (e.g., which parts of the specification do I need to test?). © 2016 IEEE.},
   author = {Jonas Winkler and Andreas Vogelsang},
   doi = {10.1109/rew.2016.021},
   month = {1},
   pages = {39-45},
   publisher = {Institute of Electrical and Electronics Engineers (IEEE)},
   title = {Automatic Classification of Requirements Based on Convolutional Neural Networks},
   year = {2017},
}
@article{auto-class_FabioDelFrate,
   abstract = {The effectiveness of multilayer perceptron (MLP) networks as a tool for the classification of remotely sensed images has been already proven in past years. However, most of the studies consider images characterized by high spatial resolution (around 15-30 m) while a detailed analysis of the performance of this type of classifier on very high resolution images (around 1-2 m) such as those provided by the Quickbird satellite is still lacking. Moreover, the classification problem is normally understood as the classification of a single image while the capabilities of a single network of performing automatic classification and feature extraction over a collection of archived images has not been explored so far. In this paper, besides assessing the performance of MLP for the classification of very high resolution images, we investigate on the generalization capabilities of this type of algorithms with the purpose of using them as a tool for fully automatic classification of collections of satellite images, either at very high or at high-resolution. In particular, applications to urban area monitoring have been addressed. © 2007 IEEE.},
   author = {Fabio Del Frate and Fabio Pacifici and Giovanni Schiavon and Chiara Solimini},
   doi = {10.1109/TGRS.2007.892009},
   issn = {01962892},
   issue = {4},
   journal = {IEEE Transactions on Geoscience and Remote Sensing},
   keywords = {Features extraction,High-resolution imagery,Information mining,Neural networks (NNs)},
   month = {4},
   pages = {800-809},
   title = {Use of neural networks for automatic classification from high-resolution images},
   volume = {45},
   year = {2007},
}

@article{class_Fulton,
    author = {Charles T. Fulton and Steven Pruess and Yuantao Xie},
    title = {The Automatic Classification Of Sturm-Liouville Problems},
    journal = {J. Appld. Math. and Comp},
    year = {}
}
@book{zettl2010sturm,
  title={Sturm-liouville theory},
  author={Zettl, Anton},
  number={121},
  year={2010},
  publisher={American Mathematical Soc.}
}



@inproceedings{synthesis_,
   abstract = {This paper describes a novel methodology to generate analog and digital circuits, autonomously, using the transistor (or other elementary device, e.g. resistor) as the basic elementary block – flat-level. A genetic algorithm is employed as the generation engine and variable length chromosomes are used to describe the circuit topology that evolves during the search. The circuit devices type and sizing are described by each gene of genetic algorithm. The automatic process starts with the circuit input and output specifications, and proceeds with the circuit topology and sizing evolution to meet those specifications, eventually, ending up with a novel topology. During the evolution, each generated circuit is electrically evaluated by a spice-like circuit simulator, i.e. Ngspice, using full model specifications - like BSIM3 for transistors - in a highly parallelized architecture built over a multi-thread model.},
   author = {Miguel Campilho-Gomes and Rui Tavares and João Goes},
   doi = {10.1007/978-3-030-45124-0_9},
   isbn = {9783030451233},
   issn = {1868422X},
   journal = {IFIP Advances in Information and Communication Technology},
   keywords = {Amplifier,Analog circuit,Automatic topology generation,Digital circuit,Genetic algorithm,Ngspice,Variable Length Chromosome},
   month = {7},
   pages = {101-108},
   publisher = {Springer},
   title = {Automatic Flat-Level Circuit Generation with Genetic Algorithms},
   volume = {577},
   url = {https://link.springer.com/chapter/10.1007/978-3-030-45124-0_9},
   year = {2020},
}
@article{synthesis_autoAx,
   title = {autoAx: An Automatic Design Space Exploration and Circuit Building Methodology utilizing Libraries of Approximate Components - IEEE Conference Publication},
   url = {https://ieeexplore.ieee.org/abstract/document/8806857},
}

@article{synthesis_Khan2017,
   abstract = {Quaternary encoded binary circuits are more compact than their binary counterpart. Although quaternary reversible circuits are realizable, design of such circuits is still in its infancy. This work proposes a new, enhanced method of quaternary Galois field sum of products (QGFSOP) synthesis for quaternary quantum circuits. To reduce QGFSOP product terms, the algorithm makes use of 11 newly defined quaternary Galois field (QGF) expansions (for a total of 21 QGF expansions). This algorithm achieves QGFSOP minimization with the assistance of a pseudo-Kronecker Galois field decision diagram (QGFDD). This is a novel approach for QGFSOP synthesis. Finally, QGFSOP expressions are translated into quantum cost optimized quaternary quantum circuits using: (1) newly developed quaternary quantum gate realizations of controlled Feynman and Toffoli gate that are optimized in terms of quantum cost, (2) use of composite literals consisting of 1 digit and M–S gates. Performance evaluation against existing works in the literature determined that our proposed method achieves an average QGFSOP expression product term savings of 32.66 %. Also, the synthesized QGFSOP circuits were evaluated in terms of quantum cost.},
   author = {Mozammel H.A. Khan and Himanshu Thapliyal and Edgard Munoz-Coreas},
   doi = {10.1007/s11227-016-1878-5},
   issn = {15730484},
   issue = {5},
   journal = {Journal of Supercomputing},
   keywords = {Quaternary Galois field decision diagram,Quaternary Galois field sum of products minimization,Quaternary reversible circuit design},
   month = {5},
   pages = {1733-1759},
   publisher = {Springer New York LLC},
   title = {Automatic synthesis of quaternary quantum circuits},
   volume = {73},
   url = {https://link.springer.com/article/10.1007/s11227-016-1878-5},
   year = {2017},
}
@inproceedings{synthesis_Meuli2018,
   abstract = {The prospective of practical quantum computers has lead researchers to investigate automatic tools to program them. A quantum program is modeled as a Clifford+T quantum circuit that needs to be optimized in order to comply with quantum technology constraints. Most of the optimization algorithms aim at reducing the number of T gates. Nevertheless, a secondary optimization objective should be to minimize the number of two-qubit operations (the CNOT gates) as they show lower fidelity and higher error rate when compared to single-qubit operations. We have developed an exact SAT-based algorithm for quantum circuit rewriting that aims at reducing CNOT gates without increasing the number of T gates. Our algorithm finds the minimum \{CNOT, T\} circuit for a given phase polynomial description of a unitary transformation. Experiments confirm a reduction of CNOT in T-optimized quantum circuits. We synthesize quantum circuits for all single-target gates whose control functions are one of the representatives of the 48 spectral equivalence classes of all 5-input Boolean functions. Our experiments show an average CNOT reduction of 26.84%.},
   author = {Giulia Meuli and Mathias Soeken and Giovanni De Micheli},
   doi = {10.1007/978-3-319-99498-7_12},
   isbn = {9783319994970},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   keywords = {Clifford+T circuits,Quantum computing,SAT-based rewriting algorithm},
   month = {9},
   pages = {175-188},
   publisher = {Springer Verlag},
   title = {SAT-based \{CNOT, T\} quantum circuit synthesis},
   volume = {11106 LNCS},
   url = {https://link.springer.com/chapter/10.1007/978-3-319-99498-7_12},
   year = {2018},
}
@inproceedings{synthesis_Miller2003,
   abstract = {A digital combinational logic circuit is reversible if it maps each input pattern to a unique output pattern. Such circuits are of interest in quantum computing, optical computing, nanotechnology and low-power CMOS design. Synthesis approaches are not well developed for reversible circuits even for small numbers of inputs and outputs. In this paper, a transformation based algorithm for the synthesis of such a reversible circuit in terms of n × n Toffoli gates is presented. Initially, a circuit is constructed by a single pass through the specification with minimal lookahead and no back-tracking. Reduction rules are then applied by simple template matching. The method produces near-optimal results for 3-input circuits and also produces very good results for larger problems.},
   author = {D. Michael Miller and Dmitri Maslov and Gerhard W. Dueck},
   city = {New York, New York, USA},
   doi = {10.1145/775832.775915},
   issn = {0738100X},
   journal = {Proceedings - Design Automation Conference},
   keywords = {Minimization,Quantum Circuits,Reversible Logic,Templates},
   pages = {318-323},
   publisher = {Institute of Electrical and Electronics Engineers Inc.},
   title = {A transformation based algorithm for reversible logic synthesis},
   url = {http://portal.acm.org/citation.cfm?doid=775832.775915},
   year = {2003},
}




@inproceedings{da-synthesis_Rybicki2015,
   abstract = {We prove exact bounds on the time complexity of distributed graph colouring. If we are given a directed path that is properly coloured with n colours, by prior work it is known that we can find a proper 3-colouring (Formula presented.)in communication rounds. We close the gap between upper and lower bounds: we show that for infinitely many n the time complexity is precisely (Formula presented.) communication rounds.},
   author = {Joel Rybicki and Jukka Suomela},
   doi = {10.1007/978-3-319-25258-2_4},
   isbn = {9783319252575},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   pages = {46-60},
   publisher = {Springer Verlag},
   title = {Exact bounds for distributed graph colouring},
   volume = {9439},
   url = {https://link.springer.com/chapter/10.1007/978-3-319-25258-2_4},
   year = {2015},
}
@thesis{da-synthesis_Klinkhamer2016,
   author = {Alex Klinkhamer},
   city = {Houghton, Michigan},
   doi = {10.37099/mtu.dc.etdr/90},
   institution = {Michigan Technological University},
   journal = {Dissertations, Master's Theses and Master's Reports},
   keywords = {distributed computing,program synthesis,self-stabilization},
   month = {1},
   title = {On the Limits and Practice of Automatically Designing Self-Stabilization},
   url = {https://digitalcommons.mtu.edu/etdr/90},
   year = {2016},
}
@article{da-synthesis_Hirvonen2017,
   abstract = {Let G be a d-regular triangle-free graph with m edges. We present an algorithm which nds a cut in G with at least (1/2 + 0.28125√d)m edges in expectation, improving upon Shearer’s classic result. In particular, this implies that any d-regular triangle-free graph has a cut of at least this size, and thus, we obtain a new lower bound for the maximum number of edges in a bipartite subgraph of G. Our algorithm is simpler than Shearer’s classic algorithm and it can be interpreted as a very efficient randomised distributed (local) algorithm: each node needs to produce only one random bit, and the algorithm runs in one round. The randomised algorithm itself was discovered using computational techniques. We show that for any fixed d, there exists a weighted neighbourhood graph Nd such that there is a one-to-one correspondence between heavy cuts of Nd and randomised local algorithms that find large cuts in any d-regular input graph. This turns out to be a useful tool for analysing the existence of cuts in d-regular graphs: we can compute the optimal cut of Nd to attain a lower bound on the maximum cut size of any d-regular triangle-free graph.},
   author = {Juho Hirvonen and Joel Rybicki and Stefan Schmid and Jukka Suomela},
   doi = {10.37236/6862},
   issn = {10778926},
   issue = {4},
   journal = {Electronic Journal of Combinatorics},
   keywords = {Cuts,Graph theory,Regular graphs},
   month = {10},
   pages = {P4.21-P4.21},
   publisher = {Australian National University},
   title = {Large cuts with local algorithms on triangle-free graphs},
   volume = {24},
   url = {https://www.combinatorics.org/ojs/index.php/eljc/article/view/v24i4p21},
   year = {2017},
}
@article{da-synthesis_Fathiyeh2015,
   abstract = {A self-stabilizing system is one that guarantees reaching a set of legitimate states from any arbitrary initial state. Designing distributed self-stabilizing protocols is often a complex task and developing their proof of correctness is known to be significantly more tedious. In this article, we propose an SMT-based method that automatically synthesizes a self-stabilizing protocol, given the network topology of distributed processes and description of the set of legitimate states. Our method can synthesize synchronous, asynchronous, symmetric, and asymmetric protocols for two types of stabilization, namely weak and strong. We also report on successful automated synthesis of a set of well-known distributed stabilizing protocols such as Dijkstra's token ring, distributed maximal matching, graph coloring, and mutual exclusion in anonymous networks.},
   author = {Faghih Fathiyeh and Bonakdarpour Borzoo},
   doi = {10.1145/2767133},
   issn = {15564703},
   issue = {3},
   journal = {ACM Transactions on Autonomous and Adaptive Systems},
   keywords = {Automated synthesis,Constraint solving,Distributed algorithms,Fault-tolerance,Formal methods,Self-stabilization},
   month = {10},
   pages = {1-26},
   publisher = {Association for Computing Machinery},
   title = {SMT-based synthesis of distributed self-stabilizing systems},
   volume = {10},
   url = {https://dl.acm.org/doi/10.1145/2767133},
   year = {2015},
}
@article{da-synthesis_Dolev2016,
   abstract = {Consider a complete communication network on n nodes. In synchronous 2-counting, the nodes receive a common clock pulse and they have to agree on which pulses are "odd" and which are "even". Furthermore, the solution needs to be self-stabilising (reaching correct operation from any initial state) and tolerate f Byzantine failures (nodes that send arbitrary misinformation). Prior algorithms either require a source of random bits or a large number of states per node. In this work, we give fast state-optimal deterministic algorithms for the first non-trivial case f=1. To obtain these algorithms, we develop and evaluate two different techniques for algorithm synthesis. Both are based on casting the synthesis problem as a propositional satisfiability (SAT) problem; a direct encoding is efficient for synthesising time-optimal algorithms, while an approach based on counter-example guided abstraction refinement discovers non-optimal algorithms quickly.},
   author = {Danny Dolev and Keijo Heljanko and Matti Järvisalo and Janne H. Korhonen and Christoph Lenzen and Joel Rybicki and Jukka Suomela and Siert Wieringa},
   doi = {10.1016/j.jcss.2015.09.002},
   issn = {10902724},
   issue = {2},
   journal = {Journal of Computer and System Sciences},
   keywords = {Byzantine fault tolerance,Distributed computing,Formal methods,SAT,Self-stabilisation,Synthesis},
   month = {3},
   pages = {310-332},
   publisher = {Academic Press Inc.},
   title = {Synchronous counting and computational algorithm design},
   volume = {82},
   url = {http://arxiv.org/abs/1304.5719 http://dx.doi.org/10.1016/j.jcss.2015.09.002},
   year = {2016},
}
@inproceedings{Chang2017,
   author = {Yi Jun Chang and Seth Pettie},
   doi = {10.1109/FOCS.2017.23},
   isbn = {9781538634646},
   issn = {02725428},
   journal = {Annual Symposium on Foundations of Computer Science - Proceedings},
   keywords = {distributed algorithm,local model,locally checkable labeling,time hierarchy theorem},
   month = {11},
   pages = {156-167},
   publisher = {IEEE Computer Society},
   title = {A time hierarchy theorem for the LOCAL model},
   volume = {2017-October},
   year = {2017}
}
@article{Brandt2017,
   author = {Sebastian Brandt and Juho Hirvonen and Janne H. Korhonen and Tuomo Lempiäinen and Patric R. J. Östergård and Christopher Purcell and Joel Rybicki and Jukka Suomela and Przemysław Uznański},
   month = {2},
   title = {LCL problems on grids},
   url = {http://arxiv.org/abs/1702.05456},
   year = {2017},
}
@inproceedings{da-synthesis_Bloem2016,
   abstract = {Fault-tolerant distributed algorithms play an increasingly important role in many applications, and their correct and efficient implementation is notoriously difficult. We present an automatic approach to synthesise provably correct fault-tolerant distributed algorithms from formal specifications in linear-time temporal logic. The supported system model covers synchronous reactive systems with finite local state, while the failure model includes strong self-stabilisation as well as Byzantine failures. The synthesis approach for a fixed-size network of processes is complete for realisable specifications, and can optimise the solution for small implementations and short stabilisation time. To solve the bounded synthesis problem with Byzantine failures more efficiently, we design an incremental, CEGIS-like loop. Finally, we define two classes of problems for which our synthesis algorithm obtains solutions that are not only correct in fixed-size networks, but in networks of arbitrary size.},
   author = {Roderick Bloem and Nicolas Braud-Santoni and Swen Jacobs},
   doi = {10.1007/978-3-319-41528-4_9},
   isbn = {9783319415277},
   issn = {16113349},
   journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
   pages = {157-176},
   publisher = {Springer Verlag},
   title = {Synthesis of self-stabilising and byzantine-resilient distributed systems},
   volume = {9779},
   url = {https://link.springer.com/chapter/10.1007/978-3-319-41528-4_9},
   year = {2016},
}
