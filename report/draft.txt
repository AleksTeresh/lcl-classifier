As was already mentioned previously, our model of computation is known as Linial's or the LOCAL model~\cite{Linial1987}. Therefore, to complete the description, I will describe in more detail two distinctive qualities of the LOCAL model from other models of distributed computing, namely unique identifiers and arbitrarily large bandwidth. Each node in the LOCAL model is provided with a unique identifier as part of initial input. The identifiers are usually assumed to be integer numbers between 1 and $|V|^c$, where $|V|$ is the number of nodes in the graph and $c$ is some constant. Unless specified, we assume that such a constant $c$ is not known by the nodes at the beginning of algorithm execution. Thus, unique identifiers are guaranteed to be positive integer numbers bounded by a polynomial in the number of nodes, but it is not known -- by the nodes at the start of algorith execution -- what is the largest unique identifier in the graph. Moreover, the identifiers of the node do not necessarily form a continuous range of integers. That is, if an integer $x$ is used as a unique identifier for some node $v$, it is possible that an integer $x+1$ is not used as an identifier in the graph. This implies that at the beginning, nodes do not known what integers have been used for unique identifiers and what have not been, with the exception of only one integer -- their own identifier. Another characteristic of the LOCAL model, which also was already mentioned before, is the fact that nodes can send (and receive) an arbitrarily large (but nevertheless finite) amount of bytes of information over a single edge during one round. This fact, combined with the existence of unique identifiers, renders the model as a rather strong one. In particular, this implies that a node can send all of its information -- no matter how large it is -- to all its neighbors in just one round. This, in turn, implies a rather curious property. Imagine that every node sends all of its information during the first round, and having received some data from its neighbors, saves all this information locally. Consider some node $v$ in the middle of a graph $G = (V, E)$. Since all nodes send all its data, after the first round, node $v$ will have all the data that all its neighbors had initially, plus its own initial information. Notice that each of $v$'s neighbors now have all the information of their neighbors. Thus, if we combine all the data in posession of $v$ and $v$'s neighbors after the first round, it is easy to observe that they together have all the information of $v$'s radius-2 neighborhood. But this means that after the second round, when all $v$'s neighbors have sent all their information to $v$, the node $v$ alone posessses all the data that its radius-2 neighborhood had at the beginning of the algorithm execution. Similarly, after the 3rd round, $v$ will have all the radius-3 neighborhood's data, and so on. In general, after round $x$, node $v$ will have all information that was initailly available in its radius-$x$ neighborhood. Therefore, when considering the LOCAL model, time and space are in certain sense equivalent. In other words, the number of rounds needed to solve a certain problem is always equal to the distance (or radius) to which a node needs to see to solve a certain problem. One technicality to note here is that because all nodes have unique identifiers, and these identifiers are sent together with the rest of data, receiving nodes can differentiate what nodes the received data belongs to, and consequently, reconstruct the structure of the neighborhood in the graph. As a consequence of the above, we can observe that after $\diam(G)$ rounds, node $v$ will have all the information there is in the graph $G$. This implies that after $\diam(G)$ rounds, in the LOCAL model, we can solve anything that can be solved in a centralized setting. That is, because at the end of $\diam(G)$'th round, each node in the graph have collected all the information there is in the graph and thus can just run the computation locally. And because local computation in the LOCAL model is virtually free, anytihng that could be computed in a centralized setting will be computed locally by each node individually. On the next round, each node can output their part of the solution.
