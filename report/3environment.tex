\chapter{Meta-algorithms used in the solution}
\label{chapter:environment}

This chapter will describe in detail all the meta-algorithms that are
used in the final solution as subroutines.
Chapter 5 will then
describe how the final solution was built on top of the meta-algorithms
described in this chapter.

\section{Round Elimination}

This section explains in detail Round Elimination (RE)
technique introduced in Chapter 2, as well as
implementation of Round Elimination as a computer
program written in Rust \cite{Brandt2019, Olivetti2020}.
Besides, we will explain the relevance of the technique
and the software implementation for our problem.

As already mentioned in the previous chapter, round elimination
is a technique that, given an LCL problem $\Pi_0$ as an input, produces
another LCL problem $\Pi_1$ which can be solved exactly one round
faster. For round elimination to work, the input should comply
to two constraints: $\Pi_0$ has to be a problem on a $(\delta, \beta)$-
biregular graph, and the number of rounds in which $\Pi_0$ can be solved
should not be "too large". Indeed, the last constraint is a rather curious one
since we rarely know round-complexity of an input problem when using
round elimination. However, we can nevertheless use this rather inconvinient constraint
to our advantage, which will be demonstrated below.

Furthermore, when applying round elimination we talk about "active" and
"passive" nodes. Since $(\delta, \beta)$-bipartition of an input problem is
already given (see our assumption above), nodes of degree $\delta$ are assumed
to be "active" and nodes of degree $\beta$ are assumed to be passive. For a problem
to be a valid input to round elimination, it has to be reformulated as a problem on
a $(\delta, \beta)$-biregular graph where only one partition of nodes produces
some output while the other partition does not produce any output but instead
checks that their radius-1 neighbourhood's outputs comply to previously
specified restrictions.

In order to demonstrate the technique, we will have as our running
examples two canonical problems: weak 3-labelling and sinkless orientation.

\textbf{Weak 3-labeling} in this context is a problem on $delta$-regular trees where
each node labels its incident edges in such a way that no node $v$ in the graph
has all its incident edges labelled with the same label. Besides if two
nodes $v$ and $u$ are incident to the same edge $e = \{v, u\}$, such
edge $e$ has to be labelled with the same label from both "sides". In other words,
two neighbouring nodes cannot output different labels on the same edge.
It is easy to see although the initial problem is specified for a regular
tree, we can obtain an equivalent problem for a $(\delta, 2)$-biregular tree
by replacing edges with nodes as described in subsection ~\ref{subsection:biregular-trees}.
Further, if we assume that all nodes of degree $\delta$ are active and all nodes of 
degree 2 are passive and that nodes of degree $\delta$ cannot have their incident
edges labelled all with the same label, and nodes of degree 2 must have both of their
incident edges labelled with the same label, we obtain an LCL problem equivalent to
weak 3-labelling but in a formalism suitable for round elimination. To formalise, we
can define the problem as following:

$$\Sigma = \{A, B, C\}$$
$$A = \{ \{A, B, C\}, \{A, A, B~or~C\}, \{B, B, A~or~C\}, \{C, C, A~or~B\} \}$$
$$P = \{ \{A, A\}, \{B, B\}, \{C, C\}\}$$
where $\Sigma$ is an allowed alphabet, $A$ is a set of \emph{configuration}
allowed for active nodes and $P$ is a set of configuration allowed for
passive nodes. Here we assumed that $\delta = 3$. Notice that each
configuration is a set of labels that are allowed to be on edges 
incident to any active/passive node $v$. Notice also that the order of
the labels in a single configuration does not matter. Finally, in this particular problem
and in all problems in the context of round elimination, we usually do not care about
leaf nodes. That is leaf nodes are unrestrained and are fine with any 
configuration.  Next, we will
describe another problem using the same formalism.

\textbf{Sinkless orientation} (SO) is a problem on a $\delta$-regular tree
where each non-leaf node has outdegree of atleast 1. Similar to the case of weak 3-labelling,
we can replace each edge with a node of degree 2 to get to $(\delta, 2)-biregular$ tree with
nodes of degree $\delta$ being active and nodes of degree 2 being passive.
Then we can define the problem formally as follows:

$$\Sigma = \{I, O\}$$
$$A = \{ \{O, I~or~O, I~or~O\} \}$$
$$P = \{ \{I, I~or~O, I~or~O\}\}$$
Here we again assumed that $\delta = 3$. Label $I$ here represents
an incoming edge and label $O$ represents an outgoing edge.
Note that because the labels are produced only by active nodes,
outgoing edge $O$ for an active node is an incoming edge for a 
passive node. And vise versa: an incoming edge $I$ for an active node
is an outgoing edge for a passive node. Thus, the sets of configurations
$A$ and $P$ can be interpreted so that each node - no matter active or passive -
has to have at least one outgoing edge, and the rest of the edges can be anything.

Now that we have defined our two example problems,
we will apply round elimination
technique on each one, describe intermediate steps, and analyse the results.
Notice that the low-level technicalities of round elimination
are omitted in the current thesis for brevity. For in-depth technical details, a reader is encouraged
to refer to the original paper by Brandt or to the recently published textbook on distributed algorithms
by Hirvonen et al~\cite{Brandt2019, Hirvonen2020}.

Let's denote the initial weak 3-labelling problem as $\Pi_0$. After applying round elimination, we get as its
output another LCL problem $\Pi_1$. The formal description of the problem is as follows:

$$\Sigma = \{A, B, C\}$$
$$A = \{ \{A, A\}, \{B, B\}, \{C, C\}\}$$
$$P = \{ \{A, B ,C\}, \{A, A, B~or~C\}, \{B, B, A~or~C\}, \{C, C, A~or~B\} \}$$
The problem $\Pi_1$ is not zero round solvable since after zero rounds each node only
knows its own degree and unique identifier. Thus, no matter what is the mapping from
unique identifiers to the output is, we can construct such a graph, where there exists
a passive node whose all 3 neighbours will output the same label. But set $P$ does not
contain any configurations consisting of the same three labels, therefore such
output would be invalid. So we just have another problem that looks a lot like our
previous problem $\Pi_0$ (essentially sets $A$ and $P$ have simply been swapped).
Let us run round elimination once again, now using $\Pi_1$ as its input. We obtain
$\Pi_2$ the following:

$$\Sigma = \{A, B, C, D, E, F, G\}$$
$$A = \{ \{C, E, F\}, \{C, D, G\}, \{B, E, G\}, \{A, F, G\}\}$$
$$P = \{ \{ACEG, ACEG\}, \{BCFG, BCFG\}, \{DEFG, DEFG\} \}$$
where we use $X_1X_2...X_k$ notation to mean the same as $X_1~or~X_2~or~...~or~X_k$.
Now this problem is zero round solvable. Indeed, if all active nodes output $\{C, E, F\}$
on their incident edges in an arbitrary order, passive nodes will be satisfied (that is to say
that all passive nodes will find a configuration from the ste $P$) in all cases.

Now since we know that $\Pi_2$ is 0-round solvable, using the jutification already described
above, we can conclude that our original problem $\Pi_0$ is exactly 2-round solvable. Thus,
weak 3-labelling on $(3, 2)$-biregular graphs is solvable in $O(1)$ rounds. Observe that
we have just used round eliminaton technique to \emph{prove} that an LCL problem can be
solved in constant number of rounds.

Next, we'll analyse SO in a similar manner. Let's again denote SO as $\Pi_0$ and apply
round elimination to it. We obtain the following output problem:

$$\Sigma = \{A, B\}$$
$$A = \{ \{A, B, B\} \}$$
$$P = \{ \{B, AB, AB\}\}$$
Applying round elimination once again, we get

$$\Sigma = \{A, B\}$$
$$A = \{ \{A, B, B\} \}$$
$$P = \{ \{B, AB, AB\}\}$$
It turns out that $\Pi_2 = \Pi_1$. But we also know that round complexity of $\Pi_2$
has to be smaller by 1 round than that of $\Pi_1$. Although this sounds like a contradiction,
it turns out that the key here is to pay attention to the initial assumptions that we mentioned at the
beginning of the section. Namely, the number of rounds $T$ of teh original problem cannot be "too large".
Hence, in the case of SO, the number of rounds necessary to solve it is "too large". Moreover,
it has been shown that is cases like this, when after applying round elimination repeatedly,
we encounter a problem that we've already seen before, the initial problem $\Pi_0$ is most of the cases
is solvable in $\Omega(log n)$ rounds in deterministic setting and in $\Omega(loglog n)$ rounds
if randomness is allowed. Thus, we can use round elimination not only to prove upper bounds but
also lower bounds for LCL problems on biregular graphs.

Although we have only demonstrated the technique for two problems, the same idea following for most of the
other LCLs on biregular graphs. In general RE can be used in an atomatic manner to prove constant upper or
logarithmic and polylogarithmic lower bounds for a wide range of LCL problems. Furthermore, the open-source
implementation
of the technique written in programming language Rust and publicly available as a command-line tool and via
a web interface will hugely assist in using RE as part of our software solution for automated classification
of LCL on trees.

\section{Automata-theoretic lens classifier}

In this section we will describe a technique that can be used to automatically
classify LCL problems on paths, cycles, and in some case on rooted trees.
Moreover, such classification can be done in polynomial time in the size
of the description of the problem being classified~\cite{Chang2020}.

On a high level, the classification algorithm first represents an input LCL problem as
a directed graph and then by analysing the graph and its properties decides
which complexity class the given LCL problem belongs to. First, however, similar to
the case of round elimination, it is important to explain a representation which
the technique requires the input LCL problem to be in. We will initially concentrate on the case
of LCLs on paths and cycles, and only afterwards cover the extension to rooted trees.

The representation is often referred to as "node-edge-checkable" formalism.
In it, each node outputs one label on each of its \emph{ports} associated with
its incident edges. Since only paths and cycles are allowed as graph families for
input LCLs, most of the nodes have exactly 2 incident edges (except for endpoints nodes
in paths, but these will be explained separately below). Therefore, a node constraint
is a pair of labels, and node constraints is a set of such pairs. Each pair essentially
means that a node can output these two labels on its incident edges. Edge constraints are,
similarly, a set of pairs of allowed labels from the perspective of an edge. For example,
consider an edge $e = \{u, v\}$. If $u$ outputs label $A$ on its port associated with edge $e$
and $v$ outputs label $B$ on its port associated with the edge $e$, then the constraint $(AB)$
(or alternatively $(BA)$) must be included in the set of edge constraints. Otherwise such output
would be invalid. For case of paths, where two nodes have only one incident edge, it is also
necessary to specify start-constraints and end-constraints, each consisting of a set of labels
that two of the endpoint nodes are allowed to output on their only ports. To make the
representation of the input LCLs clearer, here is an example of vertex 3-coloring in cycles
(which can also be found in the original paper)~\cite{Chang2020}:

$$C_{node} = \{ 11, 22, 33 \}$$
$$C_{edge} = \{ 12, 21, 13, 31, 23, 32 \}$$
where $C_{node}$ is a set of node-constraints and $C_{edge}$ is a set of edge-constraints.

Set $\{ 11, 22, 33 \}$ here allows each node to be colored in one of the three colors
(each node outputs its color to both ports) and each edge is allowed to connect
two nodes of any color as long as these colors are not the same (note that there is no
e.g. $11$ or $22$ in the set $C_{edge}$). To give another example, maximal matching (MM) in cycles
would be encoded in the node-edge-checkable formalism as follows:

$$C_{node} = \{ 00, 1M, M1 \}$$
$$C_{edge} = \{ 01, 10, 11, MM \}$$

It turns out that in the case of paths and cycles, all LCLs belong to one of the four
complexity classes: $O(1)$, $\Theta(log* n)$, $\Theta(n)$ and unsolvable. Notice that
the complexity class of $\Theta(log n)$ disappears in both deterministic and randomised settings.
The technique described in the paper then takes the description of a problem as 4 sets: $C_{node}$,
$C_{edge}$, $C_{start}$ and $C_{end}$ end following a polynomial time algorithm classifies the
problem into one of the four compplexity classes. The cassification technique works for all LCL
problems on trees and cycles.

Moreover, some problems on rooted trees can be classified as well. For the technique to work, the problem
has to be describable in a so-called "edge-checkable" formalism. In other words, we're allowed to
only specify constraints for the edges of the tree i.e. $C_{edge}$ set, nodes can output any label
on the ports, but any node $v$ is allowed to output exactly one and the same label on all its ports.
Also, we're not concert in the current formalism with the output of leaves and root - only nodes in the
middle of the graph are restricted. Although such a formalism imposes ceftain restrictions on problem families,
there are still a lot of interesting problems that can be classified this way. One restriction to keep in mind]
is that in edge-checkable formalism it is not possible to place restrictoins on number of certain label
among children of some node $v$. For example, problems of type "a node with label X can have at most one child with label Y"
are not possible, because if $(X, Y) \in C_{edge}$, then a node labelled with $X$ can have arbitrary number of children
with labelled with $Y$. If, on the other hand, $(X, Y) \notin C_{edge}$ and a node $v$ is labelled with $X$, then
none of its children can be labelled with $Y$.

\section{Classification of binary labelling problems}

This section is based on the results obtained by Balliu et al. ~\cite{Balliu2019c}. The paper demonstrates
that the case of binary labelling problems on (bi)regular unrooted regular trees is fully decidable in
deterministic LOCAL model. The paper also shows that in many cases, randomised complexity of an LCL problem
can also be decided following the described technique, although complete decidability in randomised setting
still remains an open research question.

As in the previous cases, we will start the section by explaining representation of an LCL that is compatible
with the described methods. The representation assumes a $(\delta, \sigma)$-biregular unrooted tree.
Such biregularity assumes proper 2-coloring of the graph is initially known.
As was already shown previously, biregularity is not actually necessary. It is
sufficient that an underlying graph of an input problem is simply a regular
unrooted tree. Given that, it is then easy to transform the $\delta$-regular tree
to a $(\delta, 2)$-biregular tree by replacing each edge $e = \{u, v\}$ with a new node that is
connected to nodes $u$ and $v$ via new edges and not connected to any other nodes. Finally,
in the given setting we do not care about nodes with smaller degrees e.g. leaves. This is
because any the irregularities in a graph can only make it easier for nodes around to solve
the problem, therefore, it was decided to leave any nodes with degrees other than $\delta$
and $\sigma$ unconstrained~\cite{Balliu2019c}.

Each problem is represented as a 4-tuple $\Pi = (\delta, \sigma, W, B)$, where
$\delta$ and $\sigma$ are degrees of \emph{regular} nodes, $W$ is a set of so-called
\emph{white constraints} and $B$ is a set of \emph{black constraints}. In order to
explain what exactly the sets $W$ and $B$ represent, it is important to recall that
this setting is concerned with \emph{binary} labeling only, which means that each node
can only output two labels on its edges. We will refer to such two labels as "zero" and "one"
labels (denoted 0 or 1). The problem is assumed to follow the edge-labeling
formalism, in which each node outputs a label on each of its incident nodes so that
any two adjacent nodes $v$ and $u$ can only output the same label on their common
incident edge $e = \{u, v\}$. In addition to this restriction, sets $W$ and $B$
restrict the choice of outputs as well. A "white" node's output is valid
if and only if the sum of labels on all its incident edges (that is summing
output labels on its incident edges as zeros and ones) is such a number $s_W$ that
$s_W \in W$. Similarly, output of a "black" node is valid if and only if
the sum of all labels on its incident edges sums to some number $s_B$ such that
$s_B \ in B$.

As an example, we will consider the already familiar \emph{sinkless orientation}
problem. The problem can be represented as $\Pi = (\delta, 2, \{0, 1, 2, \dots, delta-1\}, \{ 1 \})$,
where $\delta$ is any interger $> 2$. In this case, the degree of white nodes is
$\delta$ and the degree of black nodes is $2$. Thus, white nodes here are the "actual"
nodes of an underlying graph, while black nodes represent edges in the original graph.
Furthermore, an output label $1$ represents an edge
that is directed from a white node towards a black node, while label $0$ represents
an edge directed from a black node towards a white node. That is why
$W$ contains all integers from 1 to $\delta - 1$ but not $\delta$ - 
this signifies that each white node must have an outdegree of at least 1,
or in other words that edges of a white node cannot all be incoming.
From the set $B$ we can see that each black node must have 
exactly one incoming and one outgoing edge. This is because each edge (which is represented by a black node)
in the original graph must be properly oriented, or in other words it must
have exactly one head and one tail.

We will not go into details to describe the reasons why the decidability methods
described in the paper work. The details are very technical and require a huge
thoretical background to cover beforehand. It is worth noting however that
given a description of a problem $\Pi$, it is possible to classify it in $O(1)$
time since the authors of the paper provide a simple table where one can
easily lookup what compplexity class a certain LCL problem belongs to. Thus,
given a description of an binary labelling LCL on (bi)regular unrooted tree,
it is trivial to determine its complexity class (albeit only in deterministic setting)
for both computers and human beings.

\section{Classification of ternary labelling problems}



\section{Classification of problems on rooted trees}

<Section on yet-to-be published paper>

\section{Summary of decidablity of LCL on trees}

\begin{table}
  \begin{tabular}{|p{1.90cm}|p{1.90cm}|p{1.90cm}|p{1.90cm}|p{1.90cm}|p{1.90cm}|}
  % Alignment of sells: l=left, c=center, r=right. 
  % If you want wrapping lines, use p{width} exact cell widths.
  % If you want vertical lines between columns, write | above between the letters
  % Horizontal lines are generated with the \hline command:
  \hline % The line on top of the table
   & Paths and cycles & Labelled paths & Binary$\slash$Ternary labelling & Rooted regular trees & General trees \\
  \hline 
  % Place a & between the columns
  % In the end of the line, use two backslashes \\ to break the line,
  % then place a \hline to make a horizontal line below the row 
    Degree & 2 & 2 & any & any & any \\
  \hline

    Input labelling & no & yes & no & no & yes \\
  \hline

    Regularity & any & any & regular & regular & any \\
  \hline

    Orientation & either & either & unrooted & rooted & either \\
  \hline

    \raggedright Output labelling & any & any & binary & any & any \\
  \hline

    Decidable & yes & yes & yes$\slash$almost$^*$ & yes & partially \\
  \hline

    Upper bound & $P$ & unknown & P$\slash$unknown & $\leq$ EXP & unknown \\
  \hline

    Hardness &  & $\geq$ PSPACE &  & unknown & $\geq$ PSPACE \\
  \hline

    Complexity classes &  & det &  & rand & no \\
  \hline
    $O(1)$ &  & det &  & rand & no \\
  \hline
    \dots &  & det &  & rand & no \\
  \hline
    $\Theta(log log^* n)$ &  & det &  & rand & no \\
  \hline
    \dots &  & det &  & rand & no \\
  \hline
    $\Theta(log^* n)$ &  & det &  & rand & no \\
  \hline
    \dots &  & det &  & rand & no \\
  \hline
    $\Theta(log log n)$ &  & det &  & rand & no \\
  \hline
    \dots &  & det &  & rand & no \\
  \hline
    $\Theta(log n)$ &  & det &  & rand & no \\
  \hline
    \dots &  & det &  & rand & no \\
  \hline
    $\Theta(n^{1/k})$ &  & det &  & rand & no \\
  \hline
    \dots &  & det &  & rand & no \\
  \hline
    $\Theta(n)$ &  & det &  & rand & no \\
  \hline

  \end{tabular} % for really simple tables, you can just use tabular
  % You can place the caption either below (like here) or above the table
  \caption{Overview of LCL problems on trees}
  % Place the label just after the caption to make the link work
  \label{table:courses}
\end{table} % table makes a floating object with a title
