\chapter{Meta-algorithms used in the solution}
\label{chapter:environment}

This chapter will describe in detail all the meta-algorithms that are
used in the final solution as subroutines.
Chapter 5 will then
describe how the final solution was built on top of the meta-algorithms
described in this chapter.

\section{Round Elimination}

This section explains in detail Round Elimination (RE)
technique introduced in Chapter 2, as well as
implementation of Round Elimination as a computer
program written in Rust \cite{Brandt2019, Olivetti2020}.
Besides, we will explain the relevance of the technique
and the software implementation for our problem.

As already mentioned in the previous chapter, round elimination
is a technique that, given an LCL problem $\Pi_0$ as an input, produces
another LCL problem $\Pi_1$ which can be solved exactly one round
faster. For round elimination to work, the input should comply
to two constraints: $\Pi_0$ has to be a problem on a $(\delta, \beta)$-
biregular graph, and the number of rounds in which $\Pi_0$ can be solved
should not be "too large". Indeed, the last constraint is a rather curious one
since we rarely know round-complexity of an input problem when using
round elimination. However, we can nevertheless use this rather inconvinient constraint
to our advantage, which will be demonstrated below.

Furthermore, when applying round elimination we talk about "active" and
"passive" nodes. Since $(\delta, \beta)$-bipartition of an input problem is
already given (see our assumption above), nodes of degree $\delta$ are assumed
to be "active" and nodes of degree $\beta$ are assumed to be passive. For a problem
to be a valid input to round elimination, it has to be reformulated as a problem on
a $(\delta, \beta)$-biregular graph where only one partition of nodes produces
some output while the other partition does not produce any output but instead
checks that their radius-1 neighbourhood's outputs comply to previously
specified restrictions.

In order to demonstrate the technique, we will have as our running
examples two canonical problems: weak 3-labelling and sinkless orientation.

\textbf{Weak 3-labeling} in this context is a problem on $delta$-regular trees where
each node labels its incident edges in such a way that no node $v$ in the graph
has all its incident edges labelled with the same label. Besides if two
nodes $v$ and $u$ are incident to the same edge $e = \{v, u\}$, such
edge $e$ has to be labelled with the same label from both "sides". In other words,
two neighbouring nodes cannot output different labels on the same edge.
It is easy to see although the initial problem is specified for a regular
tree, we can obtain an equivalent problem for a $(\delta, 2)$-biregular tree
by replacing edges with nodes as described in subsection ~\ref{subsection:biregular-trees}.
Further, if we assume that all nodes of degree $\delta$ are active and all nodes of 
degree 2 are passive and that nodes of degree $\delta$ cannot have their incident
edges labelled all with the same label, and nodes of degree 2 must have both of their
incident edges labelled with the same label, we obtain an LCL problem equivalent to
weak 3-labelling but in a formalism suitable for round elimination. To formalise, we
can define the problem as following:

$$\Sigma = \{A, B, C\}$$
$$A = \{ \{A, B, C\}, \{A, A, B~or~C\}, \{B, B, A~or~C\}, \{C, C, A~or~B\} \}$$
$$P = \{ \{A, A\}, \{B, B\}, \{C, C\}\}$$
where $\Sigma$ is an allowed alphabet, $A$ is a set of \emph{configuration}
allowed for active nodes and $P$ is a set of configuration allowed for
passive nodes. Here we assumed that $\delta = 3$. Notice that each
configuration is a set of labels that are allowed to be on edges 
incident to any active/passive node $v$. Notice also that the order of
the labels in a single configuration does not matter. Finally, in this particular problem
and in all problems in the context of round elimination, we usually do not care about
leaf nodes. That is leaf nodes are unrestrained and are fine with any 
configuration.  Next, we will
describe another problem using the same formalism.

\textbf{Sinkless orientation} (SO) is a problem on a $\delta$-regular tree
where each non-leaf node has outdegree of atleast 1. Similar to the case of weak 3-labelling,
we can replace each edge with a node of degree 2 to get to $(\delta, 2)-biregular$ tree with
nodes of degree $\delta$ being active and nodes of degree 2 being passive.
Then we can define the problem formally as follows:

$$\Sigma = \{I, O\}$$
$$A = \{ \{O, I~or~O, I~or~O\} \}$$
$$P = \{ \{I, I~or~O, I~or~O\}\}$$
Here we again assumed that $\delta = 3$. Label $I$ here represents
an incoming edge and label $O$ represents an outgoing edge.
Note that because the labels are produced only by active nodes,
outgoing edge $O$ for an active node is an incoming edge for a 
passive node. And vise versa: an incoming edge $I$ for an active node
is an outgoing edge for a passive node. Thus, the sets of configurations
$A$ and $P$ can be interpreted so that each node - no matter active or passive -
has to have at least one outgoing edge, and the rest of the edges can be anything.

Now that we have defined our two example problems,
we will apply round elimination
technique on each one, describe intermediate steps, and analyse the results.
Notice that the low-level technicalities of round elimination
are omitted in the current thesis for brevity. For in-depth technical details, a reader is encouraged
to refer to the original paper by Brandt or to the recently published textbook on distributed algorithms
by Hirvonen et al~\cite{Brandt2019, Hirvonen2020}.

Let's denote the initial weak 3-labelling problem as $\Pi_0$. After applying round elimination, we get as its
output another LCL problem $\Pi_1$. The formal description of the problem is as follows:

$$\Sigma = \{A, B, C\}$$
$$A = \{ \{A, A\}, \{B, B\}, \{C, C\}\}$$
$$P = \{ \{A, B ,C\}, \{A, A, B~or~C\}, \{B, B, A~or~C\}, \{C, C, A~or~B\} \}$$
The problem $\Pi_1$ is not zero round solvable since after zero rounds each node only
knows its own degree and unique identifier. Thus, no matter what is the mapping from
unique identifiers to the output is, we can construct such a graph, where there exists
a passive node whose all 3 neighbours will output the same label. But set $P$ does not
contain any configurations consisting of the same three labels, therefore such
output would be invalid. So we just have another problem that looks a lot like our
previous problem $\Pi_0$ (essentially sets $A$ and $P$ have simply been swapped).
Let us run round elimination once again, now using $\Pi_1$ as its input. We obtain
$\Pi_2$ the following:

$$\Sigma = \{A, B, C, D, E, F, G\}$$
$$A = \{ \{C, E, F\}, \{C, D, G\}, \{B, E, G\}, \{A, F, G\}\}$$
$$P = \{ \{ACEG, ACEG\}, \{BCFG, BCFG\}, \{DEFG, DEFG\} \}$$
where we use $X_1X_2...X_k$ notation to mean the same as $X_1~or~X_2~or~...~or~X_k$.
Now this problem is zero round solvable. Indeed, if all active nodes output $\{C, E, F\}$
on their incident edges in an arbitrary order, passive nodes will be satisfied (that is to say
that all passive nodes will find a configuration from the ste $P$) in all cases.

Now since we know that $\Pi_2$ is 0-round solvable, using the jutification already described
above, we can conclude that our original problem $\Pi_0$ is exactly 2-round solvable. Thus,
weak 3-labelling on $(3, 2)$-biregular graphs is solvable in $O(1)$ rounds. Observe that
we have just used round eliminaton technique to \emph{prove} that an LCL problem can be
solved in constant number of rounds.

Next, we'll analyse SO in a similar manner. Let's again denote SO as $\Pi_0$ and apply
round elimination to it. We obtain the following output problem:

$$\Sigma = \{A, B\}$$
$$A = \{ \{A, B, B\} \}$$
$$P = \{ \{B, AB, AB\}\}$$
Applying round elimination once again, we get

$$\Sigma = \{A, B\}$$
$$A = \{ \{A, B, B\} \}$$
$$P = \{ \{B, AB, AB\}\}$$
It turns out that $\Pi_2 = \Pi_1$. But we also know that round complexity of $\Pi_2$
has to be smaller by 1 round than that of $\Pi_1$. Although this sounds like a contradiction,
it turns out that the key here is to pay attention to the initial assumptions that we mentioned at the
beginning of the section. Namely, the number of rounds $T$ of teh original problem cannot be "too large".
Hence, in the case of SO, the number of rounds necessary to solve it is "too large". Moreover,
it has been shown that is cases like this, when after applying round elimination repeatedly,
we encounter a problem that we've already seen before, the initial problem $\Pi_0$ is most of the cases
is solvable in $\Omega(log n)$ rounds in deterministic setting and in $\Omega(loglog n)$ rounds
if randomness is allowed. Thus, we can use round elimination not only to prove upper bounds but
also lower bounds for LCL problems on biregular graphs.

Although we have only demonstrated the technique for two problems, the same idea following for most of the
other LCLs on biregular graphs. In general RE can be used in an atomatic manner to prove constant upper or
logarithmic and polylogarithmic lower bounds for a wide range of LCL problems. Furthermore, the open-source
implementation
of the technique written in programming language Rust and publicly available as a command-line tool and via
a web interface will hugely assist in using RE as part of our software solution for automated classification
of LCL on trees.

\section{Automata-theoretic lens classifier}

In this section we will describe a technique that can be used to automatically
classify LCL problems on paths, cycles, and in some case on rooted trees.
Moreover, such classification can be done in polynomial time in the size
of the description of the problem being classified~\cite{Chang2020}.

On a high level, the classification algorithm first represents an input LCL problem as
a directed graph and then by analysing the graph and its properties decides
which complexity class the given LCL problem belongs to. First, however, similar to
the case of round elimination, it is important to explain a representation which
the technique requires the input LCL problem to be in. We will initially concentrate on the case
of LCLs on paths and cycles, and only afterwards cover the extension to rooted trees.

The representation is often referred to as "node-edge-checkable" formalism.
In it, each node outputs one label on each of its \emph{ports} associated with
its incident edges. Since only paths and cycles are allowed as graph families for
input LCLs, most of the nodes have exactly 2 incident edges (except for endpoints nodes
in paths, but these will be explained separately below). Therefore, a node constraint
is a pair of labels, and node constraints is a set of such pairs. Each pair essentially
means that a node can output these two labels on its incident edges. Edge constraints are,
similarly, a set of pairs of allowed labels from the perspective of an edge. For example,
consider an edge $e = \{u, v\}$. If $u$ outputs label $A$ on its port associated with edge $e$
and $v$ outputs label $B$ on its port associated with the edge $e$, then the constraint $(AB)$
(or alternatively $(BA)$) must be included in the set of edge constraints. Otherwise such output
would be invalid. For case of paths, where two nodes have only one incident edge, it is also
necessary to specify start-constraints and end-constraints, each consisting of a set of labels
that two of the endpoint nodes are allowed to output on their only ports. To make the
representation of the input LCLs clearer, here is an example of vertex 3-coloring
(which can also be found in the original paper)~\cite{Chang2020}:





\section{Classification of binary labelling problems}

\section{Classification of ternary labelling problems}

\section{Classification of problems on rooted trees}

<Section on yet-to-be published paper>

