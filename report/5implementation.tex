\chapter{Implementation}
\label{chapter:implementation}

% \section{General architecture of the tool}

% \section{Problem representation}

% \subsection{Problem normalization}

% \section{Query representation}

% \section{Batch classification and reclassification}

% \section{Integration of Round Eliminator}

\section{Web interface}

This section will briefly discuss some implementation details of
the client side of the application. First, we start explaining why
the web interface has been implmented in the first place and why it
is important. Then, we describe some of the technologies that were
chosen as part of the implementation. Finally, we describe the
reasoning behind and advantages of the forms' state being stored
as a query part of the URL.

The reason why we decided to spend additional time and implement
the web interface can be best unnderstood when considering
another tool that has recently been rising in popularity among
the distributed algorithms community -- Round Eliminator~\cite{Olivetti2020}. The tool has proved to be a very useful utility
when doing research connected to LCL problems on biregular trees.
However, if it wasn't for the web interface that Olivetti has
implemented, it is most likely that the popularity and
frequency of use of the tool would have been nowhere near the current
levels. Indeed, almost all users of the tool use it via the web
client. Otherwise, a user would need to install Rust programming
language~\cite{FIXME}, build the tool locally using the tool
called "Cargo"~\cite{FIXME} and then run it using the command-line.
It is clear that the number of people willing to do that would be
significantly smaller than number of people who ended up using
an easy-to-use web interface that requires no installation or 
configuration.

By analogy, we can assume with high confidence that significantly more
user would be willing to use our tool vie the web interface rather
than downloading the soource of the tool locally and installing
a specific version of Python programming language~\cite{FIXME}.
Moreover, the richness of the web user interface allows us to convey complicated
ideas related distributed computing in way that is easier to understand, at least for knowledgable audience. Thus, it is has been
decided to spend some time resources -- even though they were 
quite limited -- on implementing a web user interface that is
relatively easy to use and understand compared to its
command line -based analog.

As a programming language for our front end application, we decided
to use TypeScript~\cite{FiXMEs}. TypeScript is a general purpose
programming language developed and maintained by Microsoft~\cite{FIXME}. It is closely related to JavaScript programming language~\cite{FIXME}, which has become de facto standard programming language for the Web.
As a framework for our client application, we have decided to use
Svelte~\cite{FIXME}. Svelte is an open-source front end framework
written in TypeScript. Among other things, it allows a simplified
approach for application state management, and reduces initial
page load times compared to other front end frameworks~\cite{FIXME}.

For the styling of the front end, we used a minimalist CSS framework
called "Milligram"~\cite{FIXME}. It provides a good starting point
when it comes to styling a modern web application. Besides, the total
size of the framework is just 2 kilobytes when zipped~\cite{FIXME}.
This, simplicity to use, and our previous positive experience with
the framework were the decisive factors that influenced our final
choice.

As a final interesting piece of technology used, we describe properties
and our reason for choosing to use svelte-virtual-list~\cite{FIXME}.
The library allows rendering only part of the content instead of rendering
the whole of the content on a web page. In our case, this is
particularly useful as it allows us to
show tens of thousands of LCL problems (returned as part of the described above querying functionality) in a virtual list.
The virtual list, implemented via the above mentioned svelte-virtual-list library, renders only a small number (about 3-4)
LCL problems at the same time. At the same time, it allows user to
scroll through the list of problems with no noticable delay.
If not for the library, our client application would have to render
tens of thousands of LCL problems all at once. This would result in
the user interface freezing for a prologned period (up to several minutes).

Finally, we will explain the reasoning behind and benefits for
storing the state of the two forms as part of the URL's query
component. When searching for interesting query results, or even
just classifying different individual LCL problems, it is often
required to demonstrate the results to somebody else. To allow for such
a sharing, we decided to encode the state of both forms in the URL.
Thus, once e.g. the results of a query are obtained, it is possible
to copy the link and simply send it to, for example, a colleague.
When opening the link, both forms will be prefilled with
exactly the same values as those of the sender. This will make sure
that in most cases the sender and the reciever of the link will end
up with the same results displayed. Besides, if a particularly
interesting query has been discovered, it is possible to
simply copy and store the link. Oening the link in the future,
will prefill the forms with the same parameters and display
the same relevant results.

